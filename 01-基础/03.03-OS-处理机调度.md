---
title: 06.03-OS-处理机调度
tags:
  - 操作系统
  - 课内学习
categories:
  - 操作系统
mathjax: true
abbrlink: 21854
date: 2019-12-20 17:19:38
---

<br>
## 概述

处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。

<br>
### 处理机调度的层次

- 高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。
- 低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。
- 中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，

  <div align='center'><img src="http://blogfileqiniu.isjinhao.site/38d9944c-3486-467d-ae1e-87a64eaa8e55" /></div>


<br>
### 处理机调度的目标


**共同目标**

- 提升资源利用率：$ CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$。
- 公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。
- 平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。
- 策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。

**批处理系统的目标**

- 平均周转时间短：
  - 周转时间：从作业进入系统到作业完成退出系统所用的时间。
  - 平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NT_i]$
  - 带权周转时间：作业的周转时间（$ T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$
  - 平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NW_i]$
- 系统吞吐量高：单位时间内系统完成的作业数尽量多。
- 处理机利用率高。

**分时系统的目标**

- 响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。
- 均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。

**实时系统的目标**

- 截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。
- 可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第`i`帧和第`i+1`帧并行处理就能提高实时性。

<br>
## 高级调度


### 作业

- 作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。
- 作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。

<br>
### 作业控制块

Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。

<br>
### 作业运行的三个阶段

- 收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。
- 运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。
- 完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。

  <div align='center'><img src="http://blogfileqiniu.isjinhao.site/5514dcb1-1977-4326-8f23-8c3ca9ce19f4" /></div>


<br>
### 先来先服务算法

First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。
适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。

<br>
### 短作业优先算法

Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。

<br>
### 静态优先级调度算法

为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。
静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。

<br>
### 高响应比算法

高响应比算法是动态优先级算法的一种，其中$ 优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：
- 对于短作业：其要求服务时间短，优先级相对较高。
- 对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。
- 对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。
相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间<周转时间$
- 周转时间：从作业进入系统到作业完成退出系统所用的时间。
- 响应时间：等待时间+要求服务时间。

<br>
## 低级调度


### 进程调度的任务

- 保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。
- 按某种算法选取进程。
- 把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。

<br>
### 进程调度机制


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/51c80e55-e603-4592-9a7c-c454fee155c5" /></div>
- 排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。
- 分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。
- 上下文切换器：会产生两次上下文切换：
  - 旧进程和分配程序之间的切换；
  - 分配程序和新进程之间的切换。
排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。

<br>
### 进程调度方式


**非抢占方式**

一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：
- 正在执行的进程运行完毕。
- 外部环境的改变使其不能再继续运行，如程序运行发生异常。
- 进程通信或进程同步时执行了某种原语，如`Block`。
- 正在执行的进程发出I/O请求。

**抢占方式**

允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：
- 高优先级原则
- 短进程优先原则
- 时间片原则
我们后面所提到的进程调度算法其实都是抢占方式下的策略。

<br>
### 轮转调度算法

将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。 
此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：
- 批处理系统:80%的CPU周期在一个时间片内完成
- 分时系统：$ q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）

<br>
### 优先级调度算法


#### 抢占式/非抢占式


**非抢占式优先级调度算法**

即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。

**抢占式优先级调度算法**

任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。

#### 静态/动态优先权


**静态优先权**

静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：
- 进程类型；
- 进程对资源的需求；
- 用户要求。

**动态优先权**

动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得
更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率`a`提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即`FCFS算法`。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。

<br>
### 多队列调度算法

之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。
同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。

#### 多级反馈队列调度算法

1. 设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。
2. 优先级越高的进程时间片越短。
3. 当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。
4. 仅当第`i`队列空闲时才调度第`i+1`队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。
此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/12ef01d9-3f05-4ff6-9cfb-2a250ca73b4f" /></div>

**举例**

第`i`个对列的时间片为$ 2^{i-1}$。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/4ac099d2-2a5d-4b3b-acbb-1b50387dca7d" /></div>

<br>
### 基于公平原则的调度算法


#### 保证调度算法

保证每个进程都获得相同的处理机时间：
1. 跟踪计算每个进程自创建以来已经执行的时间。
2. 计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。
3. 比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。
4. 比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。
5. 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。

#### 公平调度算法

在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。

<br>
### 实时调度

实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。

#### 实时算法的分类


**非抢占式调度算法**

- 非抢占式轮转调度算法
- 非抢占式优先调度算法

**抢占式调度算法**

- 基于时钟中断的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。
- 立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/30d48a74-09c0-414d-84f9-af18b588b938" /></div>

#### 最早截止时间优先算法

Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。

**非抢占式**


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/2187a911-f433-4d65-9eba-bd4af7660494" /></div>

**抢占式**

有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/2612cb3c-d7df-4031-8b97-3292d05f638a" /></div>

#### 最低松弛度优先即算法

Least Laxity First，LLF。$ 松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。

**例**

有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/40c0060f-2a5c-40a1-8c8e-32aed3d969d6" /></div>

<br>
### 优先级倒置

即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1>P2>P3。P1和P3通过共享一个临界资源进行交互。
```c++
P1：...P(mutex); CS-1; V(mutex);... 
P2: ...Program2...;
P3：...P(mutex); CS-3; V(mutex);...
```
假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/414d2145-02ed-48c9-86a8-988dda60f4c1" /></div>

#### 优先级倒置的解决

遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/a336fb94-97da-456a-8a23-5ce5a0eeef1a" /></div>

<br>
## 死锁


### 资源分类


**可重用资源和消耗性资源**

- 可重用性资源：可供用户重复使用多次的资源。特点：
  - 互斥访问
  - 系统中此资源数目相对固定
  - 系统中大多数资源属于此类
- 可消耗性资源：临时性资源
  - 由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。

**可抢占性资源和不可抢占性资源**

- 可抢占性资源：CPU和主存，不会引起死锁。
- 不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。

<br>
### 死锁定义

如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/a6d26310-9d83-4d38-be3d-a50cbac353cb" /></div>

<br>
### 死锁的起因


#### 竞争不可抢占性资源引起死锁

一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/2bd54ddc-e4fa-46d0-a593-dd95f202ada5" /></div>

#### 竞争可消耗性资源引起死锁

```c++
P1：receive(p3,m3)； send(p2,m1)；
P2：receive(p1,m1)； send(p3,m2)；
P3：receive(p2,m2)； send(p1,m3)；
```
如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。

<br>
### 进程推进顺序非法

在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/fd646fa0-a793-4943-9249-c10e0e09e73b" /></div>

<br>
### 死锁产生的必要条件

- 互斥条件：某段时间内，某资源只能由一个进程使用；
- 请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；
- 不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；
- 循环等待条件 ：发生死锁时，有向图必构成一环路。

<br>
### 死锁处理

共有三类做法：
- 第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。
- 第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。
- 第三类是死锁发生后的检测和解除。

<br>
### 预防死锁

预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：

**破坏“请求和保持”条件**

即进程在请求资源时，它不能持有不可抢占资源。有两种做法：
1. 所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。
2. 进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。

**破坏“不可抢占”条件**

当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。

**破坏“循环等待”条件**

常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。

<br>
### 避免死锁

避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。

#### 安全状态

安全状态指的是系统能按某种进程推进顺序`(P1, P2, …, Pn)`为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列`(P1, P2, …, Pn)`为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。
为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻`i`发起申请资源请求，其此时状态为`a`，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。

#### 安全状态和死锁必要条件的区别

仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。
所以预防死锁和避免死锁的区别是：
- 预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。
- 但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。

<br>
### 银行家算法


#### 数据结构

1. 可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。
2. 最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。
3. 分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。
4. 需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。
可得：$Need[i,j]=Max[i,j]-Allocation[i,j]$

#### 算法

设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。
1. 如果$REQUEST[cusneed] [i]<= Need[cusneed][i]$，则转2；否则，出错。
2. 如果$REQUEST [cusneed] [i]<= Available[i]$，则转3；否则，等待。
3. 系统试探分配资源，修改相关数据：
   1. $Available[i]-=REQUEST[cusneed][i]$;
   2. $Allocation[cusneed][i]+=REQUEST[cusneed][i]$;
   3. $Need[cusneed][i]-=REQUEST[cusneed][i]$;
4. 系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。

#### 安全性算法

1. 设置两个工作向量$Work=Available$、$Finish=false$。
2. 从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]<=Work[j];$，如找到，执行3；否则，执行4。
3. 设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];$，$Finish[i]=true;$，循环2。
4. 如所有的进程$Finish= true$，则表示安全；否则系统不安全。

#### 举例

- 假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/ee046284-dee0-41b3-9fdb-18efbcd663a8" /></div>
- $T0$时刻的安全性

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/d87f5050-6673-4f43-9841-fd8e20ae086d" /></div>
- $P1$请求资源：$P1$发出请求向量$Request1(1,0,2)$，系统按银行家算法进行检查。
  - $Request_1(1, 0, 2)≤Need_1(1, 2, 2)$
  - $Request_1(1, 0, 2)≤Available_1(3, 3, 2)$
  - 系统先假定可为$P1$分配资源，并修改$Available,Allocation_1和Need_1$向量。由此得到的资源变换情况如上上图括号所示。
  - 再利用安全性算法检查此时系统是否安全。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/93c661fb-3c05-470c-ae0f-ef075f462e2c" /></div>
- $P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。
  - $Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。
  - $Request_4(3, 3, 0)>Available(2, 3, 0)$，让$P4$等待。
- $P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。
  - $Request_0(0, 2, 0)≤Need_0(7, 4, 3);$
  - $Request_0(0, 2, 0)≤Available(2, 3, 0);$
  - 系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。

  <div align='center'><img src="http://blogfileqiniu.isjinhao.site/b3f54307-9e0e-4913-92fd-ae8e2379ef32" /></div>

- 进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。

<br>
### 死锁的检测和解除


#### 死锁的检测

在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/05a53765-99c3-465d-97e1-e6240f500337" /></div>
具体做法如下：
1. 可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。
2. 把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。
3. 从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：
   1. 将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。 
   2. 将它记入L表中。
4. 若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。

#### 死锁的解除

死锁解除有多种做法，如下是按代价递减排序的几种。
1. 撤销所有死锁的进程。
2. 将每个进程回退到先前定义的某个检查点，再重新启动所有进程。
3. 逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。
4. 剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。
对于3和4，选择的标准可以如下：
- 以占用处理器的时间最小；
- 以产生的输出少；
- 所估计的剩余运行时间最长；
- 所占用的资源最少；
- 优先权最低。
