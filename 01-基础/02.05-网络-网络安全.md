## 网络安全威胁

### 拟人模型

在网络通信中，数据肯定有发送方和接收方，在全双工通信的时候双方既为发送者也为接受者，这便是图上的Alice和Bob，而Trudy可以指破坏通信的软件，也可以指破坏通信的主机。如：

- 病毒（virus）
- 蠕虫（worm）
- 间谍软件（spyware）：记录键盘输入、web站点访问、向收集站点上传信息等

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/7641f209-e0a7-4f79-a196-abb236cce4f5" /></div>
### Trudy可以做什么

**映射（Mapping）**

在任何网络攻击发起之前都会有一个映射，这是发起攻击前的“探路”（case the joint），即找出网络上在运行什么服务：

- 利用ping命令确定网络上主机的地址
- 端口扫描（Port-scanning）：获得主机地址后依次尝试与每个端口建立TCP连接

对策（Countermeasures）

- 记录到达的网络流量
- 分析、识别出可疑活动（IP地址和端口被依次扫描）

**分组“嗅探”（sniffing）**

- 广播介质（共享式以太网，无线网络）
- 混杂（promiscuous）模式网络接口可以接收/记录所有经过的分组/帧
- 可以读到所有未加密数据（例如账户密码）
- 不一定所有的嗅探都是有害的，Wireshark就是一个典型免费的分组嗅探软件

<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/f8af59de-5097-49fc-a1fd-a2010d4e562d" /></div>
对策

- 组织中的所有主机都运行软件，周期性监测网络接口是否工作在混杂模式
- 每段广播介质连接一台主机（如交换式以太网）

**IP欺骗（Spoofing）：**

- 直接由应用生成“原始”IP分组，可以设置分组的源IP地址字段为任意值
- 接收方无法判断源地址是否被欺骗
- e.g.: C冒充B

<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/258cf251-cf53-4dd1-ad40-2c93dea0edb3" /></div>
对策

入口过滤（ingress filtering），即路由器不转发源IP地址无效的IP分组（例如当源IP地址不属于所连接网络时）。这是很有效的对策！但是不能强制所有网络都执行入口过滤。

**拒绝服务DOS（Denial of service）**

向接收方恶意泛洪（flood）分组，淹没（swamp）接收方

- 带宽耗尽
- 资源耗尽

分布式拒绝服务攻击（DDOS）：多个源主机协同淹没接收方，例如C与另一个远程主机协同对A进行SYN攻击。

<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/3bd06301-ef88-40e2-b19f-de748801d7cc" /></div>
SYN 攻击

利用TCP连接的三次握手过程，Trudy向服务器发送第一次握手，服务器给建立TCP连接分配资源，发送第二次握手，但是Trudy在发送第一次握手之后不再做任何响应，服务器接收不到三次握手信号，一直发送第二次握手信息。大量的类似TCP连接产生后，服务器会陷于拒绝服务的状态。

对策：在接收到第一次握手信号后不立即分配资源，而是将源IP、目的IP、源端口、目的端口、随机数构成的五元组哈希成服务器的序列号`y`，并且发送二次握手信号。此时服务器不进行超时重传等机制。如果再接收到ACK为`y+1`第三次握手信号才去分配资源。所以在接收到第一次握手后服务器可以保留一份`y`到五元组的映射，这样的话在接收到ACK为`y+1`第三次握手信号之后就可以查一下`y`是否在哈希表中，如果在便可以为为客户端分配资源。

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/3f4e50e1-4b61-4a96-9324-cac5a009326a" /></div>
<br>

## 密码学名词

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/5bfae191-c089-46ce-9fc9-6292b77075ba" /></div>
在我们现今的密码学体系中，加密结果的影响因素有两个，加密算法和加密秘钥，而加密算法一般是公开的，因为创建一个加密算法是非常困难的事情。所以密文可以被表示为：$K_A(m)$，解密后的密文：$m=K_B(K_A(m))$。



### **对称秘钥加密**

对称密码是我们最容易被理解的密码算法，其对应上图就是$K_B == K_A$，也就是说对于一次加密过程，我们进行一次逆过程就可以完成解密。

**DES**

Data Encryption Standard。IBM公司研制。DES的部分部分是保密的。

- 1972年，美国国家标准局开始实施计算机数据保护标准的开发计划。
- 1973年5月13日，NBS征集在传输和存贮数据中保护计算机数据的密码算法。
- 1975年3月17日，首次公布DES算法描述。
- 1977年1月15日，正式批准为加密标准，当年7月1日正式生效。
- 1994年1月的评估后决定1998年12月以后不再将DES作为数据加密标准。

**AES**

Advanced Encryption Standard，1997年美国国家标准技术研究所NIST宣布征集AES算法，要求：

- 可公开加密方法
- 分组加密，分组长度为128位
- 至少像3DES一样安全
- 更加高效、快
- 可提供128/192/256位密钥
- 比利时学者Joan Daemen和Vincent Rijmen提出的Rijndael加密算法最终被选为AES算法。
- NIST在2001年12月正式颁布了基于Rijndael算法AES标准



### **公钥密码学**

公钥密码也是非对称密码。公钥加密算法一般由五个部分组成：

- 原文（Message）：需要加密的信息，可以是数字、文字、视频、音频等，用$M$表示。
- 密文（Ciphertext）：加密后得到的信息，用$C$表示。
- 公钥（Public Key）和私钥（Private Key），用$PU$和$PR$表示。
- 加密算法（Encryption）：若$E(x)$为加密算法，加密过程可以理解为$C=E(m)$，根据原文和加密算法得到密文。
- 解密算法（Decryption）：若$D(x)$为解密算法，解密过程可以理解为$M=D(c)$，根据密文和解密算法得到原文。

对于公钥密码学，我们不去探究他们的数学原理是什么，但是需要了解算法的特性和用途。我们先看算法的特性，在下面的其他部分再看算法的用处。

我们先不考虑公钥和私钥，将秘钥设为秘钥A和秘钥B，使用密钥A加密数据得到的密文，只有密钥B可以进行解密操作（即使密钥A也无法解密），对应的，使用了密钥B加密数据得到的密文，只有密钥A可以解密。此时我们把一个秘钥公开出去，一个秘钥自己掌握，便区分为公钥和私钥。而根据不同用途，对数据进行加密所使用的密钥也不相同，即有时用公钥加密，私钥解密；有时则相反，用私钥加密，公钥解密。



## 数字签名

### **消息完整性**

报文/消息完整性（message integrity），也称为报文/消息认证（或报文鉴别），指在传输、存储信息或数据的过程中，确保信息或数据不被未授权的篡改或在篡改后能够被迅速发现。它有几个核心目标：

- 证明报文确实来自声称的发送方
- 验证报文在传输过程中没有被篡改
- 预防报文的时间、顺序被篡改
- 预防报文持有期被修改
- 预防抵赖
  - 发送方否认
  - 接收方否认



### **密码散列函数**

密码散列函数（Cryptograph ic Hash Function）的特点：

- 散列算法公开
- H(m)能够快速计算
- 对任意长度报文进行映射，均产生定长输出
- 对于任意报文无法预知其散列值
- 不同报文不能产生相同的散列值
- 单向性：无法根据散列值倒推出报文，即对于给定散列值h，无法计算找到满足h = H(m)的报文m
- 抗弱碰撞性（Weak Collision Resistence-WCR），即对于给定报文x，计算上不可能找到y且y≠x，使得H(x)=H(y)。
- 抗强碰撞性（Strong Collision Resistence-SCR），在计算上，不可能找到任意两个不同报文x和y(x≠y)，使得
  H(x)=H(y)。

**散列函数算法**

MD5：被广泛应用的散列函数（RFC 1321）。对任意长度的报文输入，计算输出128位的散列值。但是MD5不是足够安全，1996年，Dobbertin找到了两个不同的512-bit块，在MD5计算下产生了相同的散列值

SHA-1：Secure Hash Algorithm，SHA-1要求输入消息长度$<2^{64}$，SHA-1的散列值为160位。其速度慢于MD5，安全性优于MD5。

**报文摘要**

Message digests，对报文m应用散列函数H，得到一个固定长度的散列码，称为报文摘要（message digest），记为H(m)。可以作为报文m的数字指纹（fingerprint）。

<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/4b305c4c-d1de-41b5-9fee-d9d0ae3dfab6" /></div>


### **报文认证**

**简单的报文认证**

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a4e06403-1801-4b1b-ad71-7b4ae2a50203" /></div>
在不知道散列的情况下，简单的报文认证什么都不能保证，因为在简单的报文认证中修改了报文，只要顺便修改了报文摘要就无法检测报文的正确性。

**报文认证码MAC**

Message Authentication Code。在简单报文的基础上，加上认证密钥（对称秘钥）。

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a0842382-efbc-42a8-a9a7-d3e230fee72c" /></div>
加上认证秘钥之后，只要能保证秘钥的安全性（后面会介绍如何保证对称秘钥的安全性）。但是此时仍然不能解决如下问题：

- 否认
  - 发送方不承认自己发送过某一份报文
  - 接收方不承认自己接收过某一份报文
- 伪造：接收方自己伪造一份报文，并声称来自发送方
- 篡改：接收方对收到的信息进行篡改



### 数字签名

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/426724a8-039d-4865-b37f-89ce24c7f18b" /></div>
使用数字签名后，假设Alice收到报文m以及签名，Alice利用Bob的公 解密 ，并检验来证实报文m是Bob签名的。如果成立，则签名m的一定是Bob的私钥，于是，Alice可以证实：

- Bob签名了m。
- 没有其他人签名m的可能。即这份报文只能是来自Bob。
- Bob签名的是m而不是其他报文m。因为只有Bob知道他自己的私钥。

同时，Alice没有Bob的私钥，不可能伪造，篡改Bob发来的报文。

数字签名相比于MAC又能解决更多的问题，但是数字签名不能解决“接收方不承认自己接收过某一份报文”的问题，想要解决这个问题必须采用其他的协议。



## 秘钥分发

### KDC

Key Distribution Center。对称秘钥的问题便是如何建立共享秘钥。即在Alice和Bob通信过程中，如何保证双方接收到的会话秘钥都是正确的且没有被Trudy接收到。而解决办法就是设立一个可信任的密钥分发中心作为中介。

密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的。

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/42c86c06-43e6-4664-9d22-88dcdedd98c8" /></div>
KDC的工作方式如下：

1. Alice使用自己和KDC共享的那一份秘钥加密自己和Bob的信息。表示自己想和Bob通信。
2. KDC使用Bob和KDC共享的那份秘钥加密Alice的信息和给本地通信颁发的会话秘钥R1。设为E。
3. KDC将E用Alice的秘钥加密，发送给Alice。
4. Alice用自己的秘钥解密后，可以获得E。
5. Alice将E发送给Bob，Bob用其有KDC共享的秘钥解密E后就可以知道自己需要和Alice使用R1通信。

<div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/f78cb111-1f00-4397-b672-88e903ef0c8a" /></div>
使用KDC进行通信加密的时候有个破绽，就是Alice和Bob与KDC之间共享的那份秘钥



### CA

Certification Authority。公钥通信的问题就是如何保证接收方接到的是发送方的公钥。即如何避免中间人攻击。

**中间人攻击**

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/0cbec0df-c73f-4fe5-986c-9f5688d3469b" /></div>
1. Bob给Alice发送自己公钥，这个消息被Trudy接收到了。此时Trudy有了Bob的公钥。
2. Trudy将自己的公钥发送给了Alice，此时Alice有的是Trudy的公钥。
3. Bob给Alice发送消息，消息被Trudy截获，Trudy有Bob的公钥能解密Bob的报文。
4. Trudy给Alice发送假消息，Alice用第二步获得的Bob的公钥解密，以为是Bob给自己发送的消息。

**可信任的认证中心**

中间人攻击的解决方案就是寻找一个可信任的认证中心。实现特定实体E与其公钥的绑定

- 每个E（如人、路由器等）在CA上注册其公钥。需要Bob的个人信息和Bob的公钥。
- CA创建绑定E及其公钥的证书（certificate）
- 证书包含由CA签名的E的公钥 – CA声明：“这是E的公钥”

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/617bc167-697e-4975-a0a8-4b4c280bb8c4" /></div>
可信赖的认证中心可以解决很多问题，但是还有一个缺陷，就是Bob怎么获得CA的公钥？如果Bob通过网络获取CA的公钥，那么仍然会被中间人攻击，所以在现在的浏览器、操作系统中已经内置了一些认证中心的公钥。这样的话，Bob发送给CA的信息就不可能被劫持。Alice也能使用内置的公钥解密CA签发的公钥证书。



## HTTPS

**数字证书**

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/e95c0b5b-eb54-474e-95c4-e4051c7d961a" /></div>
**https基本原理**

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/141df582-50fe-4a61-95d8-801fc99828f2" /></div>
**回放攻击的抵御**

我们上面的https能够抵御中间人攻击，但是却无法抵御回放攻击。什么是回放攻击呢？

假如Alice想向Bob转10块钱。Alice发送一个报文个给支付宝，Alice和支付宝之间的通信使用https进行加密，此时Trudy通过嗅探的方式获得了这个数据包，虽然Trudy无法知道这个报文的内容是什么，但是如果Trudy将这个报文多次发送给支付宝，Alice就相当于转了好多次钱给Bob。那么该如何解决呢？

*一次性随机数*

Alice在向服务器发送转账报文之前，先向服务器申请一个一次性随机数，服务器在生成这个随机数`R`后一边将其存储在服务器上（设为表`X`），一边再将其发送给Alice。然后在发送转账报文的时候将`R+1`附在报文上，服务器收到报文后解密报文再减一得到便可以得到`R`，然后再查表`X`，此时服务器就知道`R`没有被使用过，在处理完此次请求后，服务器将`R`从表`X`中删除。如果Trudy伪造了一份报文发送给服务器，服务器在表中查不到`R`，便不会处理此次请求。

*过期时间*

一次性随机数可以抵御回访攻击，但是还有点缺陷，就是如果Alice在获得`R`后不发送转账报文，表`X`中的`R`永远不会被删除，就会造成内存泄漏。此时可以将表中的每个随机数设置一个过期时间，便可以很好的解决这个问题。



## SSH

SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。

SSH使用的加密方式也是公钥加密技术，所以其和https面临相同的问题，就是中间人攻击。但是和https寻找CA认证不同，SSH采用用户自行确认的方式进行认证。

所以在第一次登录到对方主机的时候，系统会出现类似下面的提示：

```
$ ssh user@host

The authenticity of host 'host (12.18.429.21)' can't be established.

RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.

Are you sure you want to continue connecting (yes/no)?
```

很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。

如果用户经过核对（或者不核对）之后确定是对方主机，就可以和对方主机建立连接。然后便是输入用户名密码的环节了。



## 参考

- 哈尔滨工业大学mooc
- [码农翻身](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513779&idx=1&sn=a1de58690ad4f95111e013254a026ca2&chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&mpshare=1&scene=1&srcid=1218TNdDIgHKi0iNGqcuUHIK&sharer_sharetime=1576679757750&sharer_shareid=4ee2705235be865f9b9d37ec8d0880da&key=24f4c229624f48232229f8ff098300bbabbf27cc8205e886555c110b686feecc3ec87498d571e56403557416f09a3398afeb9fb53cbd747d5d6f67e079f7012ee64f504c893b7a5c616cc692fc42e431&ascene=1&uin=MTE0ODk0OTI2&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=AS6xaCbzJExHlv9GvBG8bcc%3D&pass_ticket=XKq1g7kn6ID3JUkISrEmy5kSZzr7rf2NdClQ0jY13cY%3D)
- https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html