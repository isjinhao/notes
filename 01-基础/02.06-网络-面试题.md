## TCP 对比 UDP

**对比**

- TCP提供面向连接的、可靠的数据流传输，TCP传输单位称为TCP报文段。
- UDP提供的是非面向连接的、不可靠的数据流传输。UDP传输单位称为用户数据报。

**应用层协议**

> TCP对应的协议

- FTP：定义了文件传输协议，使用21端口。
- SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
- POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
- HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。

> UDP对应的协议

- DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。



## TCP的可靠传输

**差错控制**

TCP保证差错控制使用的方式是：校验和 & 确认与重传

> 校验和

校验和的目的是为了保证接收端接收到的数据不会因为网络的不稳定导致数据出错。

> 确认与重传

确认和重传机制是为了保证报文段在传输的时候没有发生丢失。

**流量控制**

流量控制的目的是为了保证传输两端之间速率的匹配。即不能由于发送方发送的速度太快而导致接收在接收到数据后来不及处理而被迫丢弃进而引起发送方重传。

使用GBN协议或者选择重传协议来控制。即使用`发送-确认`的机制来协调点到点之间传输的速率。

> 接收方窗口

在流量控制阶段接收方会分配一段内存空间做为接收缓冲区。通常情况，接收方的缓存中包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走，称为未交付数据。接收缓冲区剩余的空间，即可用来接收新数据的空间，称为接收窗口（通常记为rwnd）。若应用进程迟迟不讲缓存区中的数据取走，随着不断接收新数据，接收窗口（可用的接收缓存）会越来越小，直到为零。而对于任何时刻：`rwnd(接收窗口)=缓冲区大小-未交付数据字节数`。

**拥塞控制**

拥塞控制作用于网络，它防止过多的数据注入到网络中，避免出现网络负载过大的情况。

> 阻塞的检测

- 全阻塞：超时表示网络全阻塞。
- 半阻塞：三次重复ACK表示网络半阻塞。

> 拥塞控制策略

1. 慢开始，指数增大
2. 到达慢开始门限值（ssthresh）的时候进行加法增大（起始的慢开始门限值是人为设置的）
3.  当发生全阻塞时
   1.  ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2
   2. 将拥塞窗口重新设置设为1。cwnd =1
   3. 进入慢启动阶段。
4. 当发生半阻塞时
   1.  ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2
   2. 将拥塞窗口设为门限值。 cwnd=ssthresh
   3. 进入拥塞避免阶段。

<div align="center"><img width="70%" src="http://q0l9qvfyx.bkt.clouddn.com/74e6326a-2cfb-4c0e-bded-d9cba2da99d1" /></div>


## TCP的三次握手和四次挥手

**三次握手**

- 客户端向服务器发送建立连接请求，并且携带一个客户端起始序列号。
- 服务器向客户端确认已收到客户端的序列号，并且将服务器起始序列号发送给客户端。
- 客户端收到服务器的序列号之后，客户端向服务器确认已收到服务器序列号。

<div align="center"><img width="60%" src="http://q0l9qvfyx.bkt.clouddn.com/c5150931-5dea-4eba-9e6a-6ba4ec5ed059" /></div>
- 客户端状态：
  - SYN_SENT：客户端发送请求给服务器后的状态
  - ESTABLISHED：客户端进入连接建立状态
- 服务器状态：
  - SYN_RECV：服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态
  - ESTABLISHED：服务器进入连接建立状态

**二次握手的缺陷**

> 二次挥手不能防止已失效的连接请求又传送到服务器端。

- 客户端发送第一个请求给服务器（第一次`第一次握手`），如果这个请求在网络上迷失，客户端在超时之后会再发一次请求给服务器（第二次`第一次握手`）
- 服务器收到第一次握手的这个连接之后会发送ACK给客户端（`第二次握手`）。
- 在二次握手的情况下，客户端不发送ACK，此时可以进行通信。
- 此时若我们第一次发送的`第一次握手`信号达到了服务器，那么服务器以为是新的连接，就会发确认报文到客户端确认并建立连接，但发送端可能已经关闭，接收端可能就这样等待，这在网络中就浪费了资源。
- 但是有了`第三次握手`不一样了，服务器在接收到了滞留在网络中的信息后，会发送确认信息给客户端，但是当客户端没有理会的时候，服务器在超时之后就会自动关闭这次连接。

**四次挥手**

连接断开时可以先由服务器发起，也可以先由客户端发起。下面假设是客户端发起的连接断开。

- 客户端向服务器发送一个FIN报文段；此时，服务器进入FIN_WAIT_1状态。这表示客户端没有数据要发送给服务器了。
- 服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，服务器进入CLOSE_WAIT状态。表示服务器知道客户端没有数据要传送过来了，服务器自己进入`等待关闭`状态，表示发完手上的数据就进行关闭。
- 服务器发完手上的数据后向客户端发送FIN报文段来请求关闭连接。这表示客户端服务器已经没有数据要传给客户端了。
- 客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段。服务器收到客户端的ACK报文段以后，就关闭连接。此时服务器关闭连接完成。如果客户端等待2MSL后依然没有收到回复，客户端的定时器关闭，表示客户端关闭连接完成。

<div align="center"><img width="60%" src="http://q0l9qvfyx.bkt.clouddn.com/7b9939d2-b1fc-4cc9-aa44-c2e486888200" /></div>
- 客户端状态：
  - FIN_WAIT_1：客户端发送FIN报文段后的状态
  - FIN_WAIT_2：客户端接收到服务器的ACK报文段之后的状态
  - TIME_WAIT：客户端接收到服务器发送的最后一个ACK之后，进入一个2MSL的等待期。
- 服务器状态：
  - CLOSE_WAIT：服务器接收到客户端请求关闭的报文之后进入关闭等待期
  - LAST_ACK：服务器发送完关闭连接报文段后（FIN）等待接收客户端的确认的状态。

**为什么四次挥手后需要等待一段时间**

1. **为了保证客户端发送的最后一个ACK报文能够到达服务器。**这个ACK的报文有可能丢失，这样处于LAST-ACK状态的服务器如果收不到客户端的ACK报文，会再次发送`第三次挥手`信号，而客户端在2MSL的时间内收到这个重传的信号。接着客户端重传一次确认，重新启动2MSL计时器。如果客户端不在TIME-WAIT状态下等待一段时间，而是在发送完ACK报文后立即释放连接，那么就无法收到重传的`第三次挥手`报文，因而也不会再一次的发送确认报文，那么服务器就会永远进行重传。
2. **避免新旧连接混淆。**等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接请求不会出现旧的连接请求报文。我们假设TCP连接是`A(1.2.3.4:8888)-B(6.7.8.9:9999)`，这就是一个TCP四元组。当TCP连接关闭后，四元组释放。后面的新连接可能会重用到这个四元组，那么问题就来了：新四元组和旧四元组完全一致，他们的网络包会产生混乱。所以等待一段时间可以让旧四元组对应的所有网络包都消失，避免新旧连接混淆。 



## 网络模型

<div align="center"><img width="80%" src="http://q0l9qvfyx.bkt.clouddn.com/db782db0-9889-4ba0-a9a3-92684553f7b5" /></div>
**各层的功能**

> 应用层（application layer）

是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。

协议：HTTP协议、SMTP协议、FTP协议、DNS、POP3、SNMP、Telnet

> 运输层（transport layer）

负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能

- 复用，就是多个应用层进程可同时使用下面运输层的服务。
- 分用，就是把收到的信息分别交付给上面应用层中相应的进程。

协议：UDP协议、TCP协议

> 网络层(network layer）

网络层(network layer)主要包括以下两个任务：

- 负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。
- 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。

协议：IP、ICMP、IGMP、ARP、RARP

> 数据链路层（data link layer）

将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。

协议：GBN协议、选择重传协议

> 物理层（physical layer）

物理层的任务就是透明地传送比特流。



## HTTPS

