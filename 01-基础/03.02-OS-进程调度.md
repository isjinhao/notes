---
title: 06.02-OS-进程调度
tags:
  - 操作系统
  - 课内学习
categories:
  - 操作系统
mathjax: true
abbrlink: 58
date: 2019-12-20 17:19:38
---

<br>
## 进程概念


### 前趋图

数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/5f58725a-616a-4a24-90c5-9896c8172650"></div>
<br>
### 程序的并发执行

不存在前趋关系的程序之间才有可能并发执行。特征：
- 间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。
- 失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。
- 不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。

<br>
### 进程的定义

在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。
- 进程实体：程序+数据+进程控制块（Process Control Block，PCB）。
- 进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。
PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。
区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。

<br>
### 进程的特点

- 动态性：由创建而产生，由调度而执行，由撤销而消亡。
- 并发性：进程的重要特征，操作系统的重要特征。
- 独立性：独立运行、独立分配资源、独立接受调度。
- 异步性：按各自独立、不可预知的速度向前推进。

<br>
## PCB


### PCB中保存的信息

- 进程标识符。用于唯一的标识某个进程。
  - 外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。
  - 内部标识符：方便系统使用进程，仅能标识进程。
- 处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。
- 进程调度信息。
  - 进程状态：指明进程的状态，方便进程调度和对换时的依据。
  - 进程优先级：进程优先级高的更容易获得处理机。
  - 进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。
  - 事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。
- 进程控制信息。
  - 程序和数据的地址。
  - 进程同步的通信机制。
  - 资源清单。进程已分配到的除处理机之外的资源。
  - 链接指针。用于指向下一个PCB的首地址。用于进程调度。

<br>
### PCB的组织方式

- 线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。
- 链接方式：把具有相同状态的PCB链接起来。
- 索引方式：把具有相同状态的PCB保存在相应的表中。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/3094cb7a-bffa-4d13-8d8a-9e6458c2098b" /></div>
<br>
## OS内核


### 系统态 & 用户态

对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。

<br>
### 指令分类

操作系统把CPU指令分成两类：
- 特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。
- 非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。

<br>
### 内核概念

现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与**硬件紧密相关的程序**、**设备驱动程序**和**运行频率高的程序**等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。

#### 内核的功能

不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：
- 支撑功能
  - 中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。
  - 时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。
  - 原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。
- 资源管理功能
  - 进程管理：进程的创建、撤销、调度等操作。
  - 存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。
  - 设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。

<br>
## 进程的生命周期


### 进程的创建

1. 为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。
2. 为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。
3. 初始化PCB。如处理机状态信息、标识符和进程优先级等。
4. 若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。

<br>
### 进程的终止

1. 从PCB集合中获得某进程的PCB，并读出该进程的状态。
   - 若进程正处于执行状态，应立即终止该进程的执行。
   - 若此进程有子进程则一并终止，防止其成为不可控进程。
2. 将进程拥有的所有资源归还给其父进程或操作系统。
3. 将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。

<br>
### 三种基本状态

- 就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。
- 执行状态：就绪状态的进程获得CPU，正在执行的状态。
- 阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/f044ec2c-345b-430b-bd6d-8e84ce65d839" /></div>
<br>
### 挂起

进程暂停执行或不接受调度的状态。原因有如下几点：
- 用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。
- 父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。
- 负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。
- 操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。
挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/e1bf9eb8-939f-4235-b97d-6f9ffcaecd1e" /></div>
<br>
##  <span id="jump">进程同步</span>

进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。

<br>
### 同步 & 互斥

并发执行的诸进程之间既有独立性又有制约性。
- 独立性：各进程都可独立地向前推进；
- 制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。
  - 同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。
  - 互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。

<br>
### 临界资源 & 临界区

- 临界资源：需要被各进程互斥访问的资源。
- 临界区：各进程中访问临界资源的代码。
若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。

<br>
### 同步准则

- 空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。
- 忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。
- 有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。
- 让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。

<br>
## 硬件同步机制


### 关中断

当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。

<br>
### 利用Test-and-Set指令实现互斥

指令的描述如下：
```c
boolean TS(boolean *lock){
    boolean old;
    old = *lock;
    *lock = true;
    return old;
}
```
为临界资源设置一个布尔变量`lock = false`。在进程进入临界区之前利用TS指令测试，如果得到的值为`false`表示资源未被使用，如果得到的值为`true`，则一直测试到结果为`false`。使用TS指令实现互斥描述如下：
```c
do{
	...
	while (TS(&lock));
	...
	lock = false;
	...
}while(true);
```

<br>
### 利用Swap指令实现互斥

指令描述如下：
```c
void swap(boolean *a, boolean *b){
    boolean temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
```
为每个临界资源设置一个全局变量`lock=false`。每个进程设置一个局部变量`key`。实现互斥的描述如下：
```c
do{
	...
    key = true;
    do{
        swap(&lock, &key);
    }while(key != false)
    critical section;
    lock = false;
    ...
}
```

<br>
### 缺点

- 关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。
- TS指令 & Swap指令：其他进行会”忙等“，不符合让权等待。

<br>
## 信号量机制


### 整型信号量

整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。
- wait(S)：P操作
  ```c
  wait(S){
      while(S <= 0);
      S--;
  }
  ```
- signal(S)：V操作
  ```c
  signal(S){
      S++;
  }
  ```
P操作用于分配资源，V操作用于释放资源。

<br>
### 记录型信号量

整型信号量未遵循让权等待原则。只要`S <= 0`就会不断的循环。此时需要增加一个进程链表指针链接等待进程。
- 数据结构的描述：
  ```c
  typedef struct{
      int value;	// 资源数
      struct process_control_block *list;	// 阻塞队列
  } semaphore;
  ```
- wait(S)：
  ```
  wait(semaphore *S){
      S->value--;
      if(S->value < 0)
      	block(S->list);
  }
  ```
- signal(S)：
  ```c
  signal(semaphore *S){
      S->value++;
      if(S->value <= 0)
      	wakeup(S->list);
  }
  ```
当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。

<br>
### AND型信号量

记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。
- Swait(S)：
  ```c
  Swait(S1, S2, ..., Sn) {
      if(Si >= 1 && ... && Sn >= 1) {
          for(i = 1; i <= n; i++)
              Si--;
          break;
      } else {
          // 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器
          // （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次
          // 检查所有的资源）。
      }
  }
  ```
- Ssignal(S)：
  ```c
  Ssignal(S1, S2, ..., Sn) {
      for(i = 1; i <= n; i++) {
          Si++;
          // 唤醒等待Si资源的阻塞队列。
      }
  }
  ```

<br>
### 信号量集

之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：
```c
Swait(S1, t1, d1, ..., Sn, tn, dn){
    if (S1 >= t1 && ... && Sn >= tn)
        for(i = 1; i <= n; i++){
            Si -= di;
        }
    else {
        // 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器
        // （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次
        // 检查所有的资源）。
    }
}
// 这里有个问题，就是 Si > ti 之后，能保证Si > di吗？我个人的理解是di和ti的资源量是动态的，比如di为4，
// 原始ti为2，那程序在运行到Swait之前，si会被修改为6。
```
```c
Ssignal(S1, S2, ..., Sn) {
    for(i = 1; i <= n; i++) {
        Si += di;
        // 唤醒等待Si资源的阻塞队列。
    }
}
```

**特殊的信号量集**

- `Swait(S1, d, d)`：每次申请d份资源，资源少于d时不分配。
- `Swait(S, 1, 1)`：退化成一般的记录型信号量。
- `Swait(S, 1, 0)`：`S >= 1`时允许进程进行进入特定区。`S <= 0`时禁止进程进入特定区。

<br>
### 管程

直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。
此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将`block`和`wakeup`操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：
- `condition.wait()`：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。
- `condition.signal()`：唤醒因某条件不能满足而阻塞的进程。
可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。使用时把`signal()`操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。

**管程的描述如下：**

```c
/*
	1、局部数据和条件变量组成管程内的数据结构。
	2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。
	3、初始化代码：对管程内的数据结构进行初始化。
*/
Monitor monitor_name{
    share variable declartions; //共享变量说明
    condition declarations;		//条件变量说明
    {	//管程主体
        initialization code;    //初始化代码
        ...
    }
    public:		//能被进程调用的过程
    	void P1(...){...}
    	void P2(...){...}
    	...
    	void Pn(...){...}
}
```

<br>
## 信号量的应用


### 互斥访问资源

设某共享资源的信号量是`mutex`，PA和PB进程并发时需互斥访问。
```c
semaphore mutex = 1;
PA(){
    while(1){
    	...
        wait(mutex);
        ...
        signal(mutex);
        ...
    }
}
PB(){
    while(1){
        ...
        wait(mutex);
        ...
        signal(mutex);
        ...
    }
}
```

<br>
### 利用信号量实现前趋关系


<div align="center"><img src="http://blogfileqiniu.isjinhao.site/e6058fc8-cf80-40ae-bec9-123125d36b92" /></div>
```c
P1（）{...V(f1);V(f1);V(f1);}
P2（）{P(f1)；... V(f2);}
P3（）{P(f1)；... V(f3);}
P4（）{P(f1)；... V(f4);}
P5（）{P(f2)；... V(f5);}
P6（）{P(f3);P(f4);P(f5);...;}
main(){
    semaphore f1=f2=f3=f4=f5=0；
    Cobegin
    	P1(); P2();P3(); P4();P5(); P6();
    Coend
}
```
在并发时，如果`P1`的功能代码未执行完，`f1`为0，每次对`f1`进行V操作能使`P2`、`P3`、`P4`运行一个。其他亦然。

<br>
### 生产者—消费者问题


**问题描述**

多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/f23286c5-6773-4bd1-9e94-fc96dc382ed3" /></div>
**分析**

- 任何时刻，只能有一个进程在缓冲区中操作。
- 对于“生产者”而言，缓冲区满则应等待。
- 对于“消费者”而言，缓冲区空则应等待。

**利用记录型信号量解决问题**

```c
int in = 0, out = 0;	// in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。
item buffer[n];		// 缓存区大小为n，地址为[0, n-1]。
semaphore mutex = 1, empty = n, full = 0;	// mutex用于互斥访问缓存区
void producer(){
    do{
        produce an item nextproducer;
        ...
        wait(empty);	//消耗一个empty，当empty<=0时等待
        wait(mutex);	
        buffer[in] = nextproducer;
        in = (in+1) % n;
        signal(mutex);
        signal(full);	//增加一个full
    }while(true);
}
void consumer(){
    do{
        wait(full);		//消耗一个full，当full<=0时等待
        wait(mutex);
        nextconsumer = buffer[out];
        out = (out+1) % n;
        signal(mutex);
        signal(empty);	//增加一个empty
        ...
    }while(true);
}
void main(){
    ConcurrentBegin
        produce();consumer();
    ConcurrentEnd;
}
```

**互斥信号量 & 资源信号量**

互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。
在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了`P(mutex)`，阻塞在`P(empty)`，消费者通过了`P(full)`，阻塞在`P(mutex)`，此时生产者等待消费者的`V(empty)`，消费者等待生产者的`V(mutex)`，发生死锁。而V操作不需要注意顺序。

**利用AND型信号量解决问题**

```c
int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。
item buffer[n];//缓存区大小为n，地址为[0, n-1]。
semaphore mutex = 1, empty = n, full = 0;	//mutex用于互斥访问缓存区
void producer(){
    do{
        produce an item nextproducer;
        ...
        Swait(empty, mutex);	//消耗一个empty，当empty<=0时等待
        buffer[in] = nextproducer;
        in = (in+1) % n;
        signal(empty, mutex);	//增加一个full
    }while(true);
}
void consumer(){
    do{	
        wait(full, mutex);	//消耗一个full，当full<=0时等待
        nextconsumer = buffer[out];
        out = (out+1) % n;
        signal(full, mutex);	//增加一个empty
        ...
    }while(true);
}
void main(){
    ConcurrentBegin
        produce();consumer();
    ConcurrentEnd;
}
```

**利用管程解决问题**

```c
Monitor monitor{
    item buffer[n];
    int in = 0, out = 0, count = 0;
    condition notfull, notempty;
    public:
    	void static put(item x){
            if(count >= n)
            	cwait(notfull);	//阻塞在队列满的条件下
            buffer[in] = x;
            in = (in+1) % n;
            count++;
            csignal(notempty);
    	}
        void static get(item &x){
			if(count <= 0)
                cwait(notempty);	//阻塞在队列空的条件下
            x = buffer[out];
            out = (out+1) % n;
            count--;
            csignal(notfull);
        }
}
void producer(){
    item x;
    while(true){
        ...
        produce an item in nextproducer;
        monitor.put(x);
    }
}
void consumer(){
    item x;
    while(true){
        monitor.get(x);
        consume the item in nextconsumer;
        ...
    }
}
void main(){
    ConcurrentBegin
        produce();consumer();
    ConcurrentEnd;
}
```

<br>
### 哲学家进餐问题


**问题描述**

五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/61be3b33-61a2-4e94-b617-a00e297a83aa" /></div>
**分析**

- 同一时刻一只筷子只能有一个哲学家拿起。
- 只有获得两个筷子后才能进餐。
- 如果每个哲学家都拿起一只筷子，都饿死。
- 并行程度：五只筷子允许两人同时进餐。

**利用AND型信号量解决问题**

每次必须拿到两只筷子才能拿起，否则不拿起筷子。
```c
semaphore chopstick[5] = {1, 1, 1, 1, 1};
do{
    ...
    Swait(chopstick[i], chopstick[(i+1) % 5]);
    ...
    Ssignal(chopstick[i], chopstick[(i+1) % 5]);
    ...
}
```

<br>
### 读者-写者问题


**问题描述**

- 写者向共享数据区放数据，读者从共享数据区读数据。
- 多个读者可同时读取数据，多个写者不能同时写数据。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/b63a44fd-5493-49d5-9586-30d2cd091a55" /></div>
**分析**

- 读者进入共享数据区，写者必须等待。
- 读者进入共享数据区，读者可以进入。
- 写者进入共享数据区，读者必须等待。

**利用记录型信号量解决问题**

```c
semaphore readmutex = 1, writemutex = 1;
int readcount = 0;
void reader(){
    do{
        wait(readmutex);
        if(readcount == 0)
            wait(writemutex);
        readcount++;
        signal(readmutex);
        ...	// read opreation
        wait(readmutex);
        readcount--;
        if(readcount == 0)
            signal(writemutex);
        signal(readmutex);
    }while(true);
}
void writer(){
    do{
        wait(writemutex);	//当写者进入共享数据区，reader会阻塞在
        ... //write operation
        signal(writemutex);
    }while(true);
}
void main(){
    ConcurrentBegin
        reader();writer();
    ConcurrentEnd;
}
```

**代码分析**

最开始并发的时候：
- 假如读者先抢到资源，`readcount == 0`，`P(writemutex)`，`writer()`会阻塞在第20行，但其他`reader()`仍可以运行，只是不会再`P(writemutex)`。同时每个`reader()`都`readcount++`，直到`readcount == 0`时`V(writemutex)`，然后`writer()`才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。
- 假如写者先抢到资源，`P(writemutex)`，此时`readcount == 0`，所有`reader()`阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。
  综上，完成了要求。

<br>
### 读者-写者问题拓展


**问题描述**

- 拓展就是又增加一个条件，最多只允许RN个读者同时读。

**利用信号量集解决问题**

```c
semaphore L = RN, mx = 1;	// L用来控制访问数，mx控制写者访问时所有读者阻塞
void reader(){
    do{
        Swait(L, 1, 1);	// 第RN+1个读者进入时会阻塞
        Swait(mx, 1, 0);// mx >= 1时才可以进入
        ...	// read operation
        Ssignal(L, 1);
    }while(true);
}
void writer(){
    do{
        Swait(mx, 1, 1; L, RN, 0);	//mx >= 1 && L >= RN时进入
        ...	// write operation
        Ssignal(mx, 1);
    }while(true);
}
void main(){
    ConcurrentBegin
        reader();writer();
    ConcurrentEnd;
}
```

**代码分析**

最开始并发的时候：
- 假如读者先抢到资源，`L = L - 1`，写者阻塞在第12行，但其他`reader()`仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。
- 假如写者先抢到资源，`mx = mx - 1`，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。

<br>
### 理发师问题


**问题描述**

一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/2b2ae3cd-36cf-4a84-a300-a0854dc51275" /></div>
**分析**

- 理发椅上只能有一位顾客。
- 等待座位是有限缓冲区。
- 只要存在顾客，理发师就不能睡觉。

**利用记录型信号量解决问题**

```c
semaphore customer = 0, barber = 0, mutex = 1; //barber使理发师只能为一个顾客服务
int waiting = 0;
void barber(){
    while(true){
        wait(customer);	//没有顾客的时候理发师睡觉
        wait(mutex);	
        waiting –= 1;	//等待的人少一个
        signal(mutex);
        signal(barber);
        ...//获得被激活进程的信息并给相应的顾客剪发
    }
}
void customer(){
    wait(mutex);	
    if(waiting < CHAIRS){	//顾客到来的时候，还有座位就进去等待
        waiting += 1;
        signal(mutex);
        signal(customer);
        wait(barber);
        ...  //将被激活进程的信息发送给barber()
    }else{
        signal(mutex);
    }
}
```

**代码分析**

在最开始并发的时候`barber()`会等待到有顾客时才醒来。顾客一来就需要访问`waiting`，所以获得`mutex`。
- 如果位置不够就立即释放`mutex`。
- 如果位置够，就让等待的人加1，再释放`mutex`。然后顾客人数`customer += 1`来激活理发师进程。理发师进程激活后会`V(barber)`，然后等待着的`customer()`进程争夺资源，争夺到`P(barber)`的进程将被激活进程的信息发送给`barber()`，`barber()`获得被激活进程的信息并给相应的顾客剪发。

<br>
## 进程通信


### 概念

进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。

<br>
### 共享存储器系统

- 基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。
- 基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。

<br>
### 管道通信系统

所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：
- 互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。
- 同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。
- 确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。

<br>
### 消息传递系统

指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：
- 直接通信方式：OS提供原语给进程使用。
- 间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。
  - 和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。

<br>
### 客户机-服务器系统

前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。
- 套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。
- RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/44d61e32-6054-4fdd-9bb2-6c911e4720c6" /></div>
<br>
## 线程


### 线程的由来

进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。

<br>
### TCB（Thread Control Block）

所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：
- 线程标识符：每个线程都有唯一的线程标识符。
- 处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。
- 线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见`103-网络编程`。
- 优先级：和调度算法有关，优先级越高，得到处理机的机会越大。
- 线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。
- 信号屏蔽：屏蔽某些发送给线程的信号。
- 堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。

<br>
## 线程的实现

线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。

<br>
### 内核支持线程

若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/cc3840cb-d3dd-4d60-a36d-d3663b3510ae" ></div>
<br>
### 用户级线程

用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。
- 运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。
  

  <div align="center"><img src="http://blogfileqiniu.isjinhao.site/c1c7f79c-7ac9-4638-8b4c-ec81b238378f" /></div>

- 内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。

<div align="center"><img src="http://blogfileqiniu.isjinhao.site/1ef49c0f-824d-47e5-8511-67b5b12a0bae" width="80%" /></div>



