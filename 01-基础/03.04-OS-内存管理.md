---
title: 06.04-OS-内存管理
tags:
  - 操作系统
  - 课内学习
categories:
  - 操作系统
mathjax: true
abbrlink: 19078
date: 2019-12-20 17:19:38
---

<br>
## 存储器的层次

我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/57187fc9-7345-44d6-af47-47ab8b2f4256" /></div>
存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层。

**主存储器**

- 用于保存进程运行时的程序和数据。
- 对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。
- CPU从主存读取指令和数据。
- CPU与外设交换信息要依托主存。
- 为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。

**寄存器**

- 访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。
- 长度一般以字为单位。
- 对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。

**高速缓冲**

- 容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。
- 访问速度快于主存。
- 将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。

**磁盘缓冲**

- 将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。
- 不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。
总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于[程序局部性原理](https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003)。

**程序局部性原理**

指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。 局部性原理又表现为：时间局部性和空间局部性。
- 时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。
- 空间局部性：一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。
另外，根据程序的局部性理论，Denning提出了工作集理论。所谓工作集是指进程运行时被频繁访问的页面集合。显然我们知道只要使程序的工作集全部集中在内存中，就可以大大减少进程的缺页次数；否则会使进程在运行过程中频繁出现缺页中断，从而出现频繁的页面调入/调出现象，造成系统性能的下降，甚至出现“抖动”。
划分工作集可以按定长时间或定长页面两种方法进行划分。当颠簸现象发生时，说明系统的负荷过大，通常采用处理器均衡调度。另一种是控制缺页率，当缺页率达到上限时，则增加内存分配量；当缺页率达到下限时，就减少内存的分配量。 

<br>
## 程序的装入和链接

用户程序要在系统中运行，必须将它装入内存，其中有三个过程。
- 编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；
- 链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；
- 装入：由装入程序(Loader)将装入模块装入内存。

<br>
### 链接

链接程序的功能是将经过编译后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。

#### 静态链接方式

生成可执行文件时进行链接。主要有两步。
1. 修改相对地址。
2. 变换外部调用符号。

#### 装入时动态链接

目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：
- 便于修改和更新。
- 便于实现对目标模块的共享。

#### 运行时动态链接

将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。
凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。

<br>
### 装入

装入是将一个具有执行资格的模块加载进内存。

#### 绝对装入方式

在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。

#### 可重定位装入方式

编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/828b8bca-cc39-4f95-b638-ac687aed4c82" /></div>
#### 动态运行时装入方式

静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/0dd5a600-9e18-4e30-ac2b-4ed1ae698a76" /></div>
<br>
### 现代计算机运行过程

- 预处理
  - 把存储在不同文件中的源程序聚合在一起。
  - 把被称为宏的缩写语句转换为原始语句。
- 编译：将高级语言翻译成汇编语言或机器语言。
- 链接
  - 将多个可重定位的机器代码文件（包括库文件）连接到一起。
  - 解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。
- 装入
  确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。

<br>
### 连续分配存储管理方式

连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80
年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。

#### 单一连续分配

这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/6832a4fb-0a2c-4580-9d61-53421c11028f" /></div>
#### 固定分区分配

固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。
为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/3dedf899-aaec-438b-8000-1697086bf1d5" /></div>
#### 动态分区分配


**数据结构**

- 空闲分区表
  - 每个空闲分区占用一个表项。
  - 分区表的表项中包含分区号、分区始址及分区大小等表目。
  - 表长不易确定。
  - 占用额外内存。
- 空闲分区链表
  - 利用各空闲分区自身的单元组成双向链表。
  - 操作速度较慢。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/50d0b9cb-d452-4651-be2f-ec582dcbf9a3" /></div>
**分区分配**


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/f97ae2b8-f686-472d-b570-dd787528f453" /></div>
**分区回收**

- 如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/903e731f-002e-47b0-8bd7-6a8fa4ece434" /></div>
- 如果回收区的前后无空闲区，新建一个表项，填写信息插入。

#### 分区检索算法


**顺序检索算法**

- 首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。
- 循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。
- 最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从
  头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。
- 最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，
  若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。

**索引检索算法**

- 快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。
- 伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。
- 哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。

#### 紧凑

可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/14408d45-b0be-4d64-96a0-7dbca67e8a9c" /></div>
<br>
## 分页存储管理方式


### 基本概念


**页面**

将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。

**物理块**

把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。

**页面碎片**

由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。

**页面大小**

每一页可进行编址的地址数目。页面大小应该满足2的n此幂。
- 方便计算：如果要将（线性）地址转换为`page：offset`，则需要将地址除以页面大小，并将整数答案作为页面，将余数作为偏移量。 这是使用编程语言中的整数除法和模数运算符完成的。 计算机将地址表示为数字，存储为二进制位。 这是一个示例地址：`12`是二进制`1100`。 如果页面大小为`3`，那么我们需要计算`12/3`和`12%3`来查找页面和偏移量（分别为`4`、`0`）。 但是，如果页面大小为`4`（`2`的幂），则二进制中的`4`为`100`，此时使用特殊的“快捷方式”计算整数除法和模数：右移进行除法，按位与进行取模。所以： `12/4 == 12>>2`（右移两位） `12%4 == 12&(4-1)`（`1100`和`11`按位与）。同时页面大小转为2进制可以使用左移，可以减小时间开销。
- 充分利用空间：如果页面大小不满足2的n次幂，假如是5，则页内偏移地址，采用2位则每页有一个地址不能使用，采用3位则`111`、`110`、`101`未被使用。怎么做都不能完全利用地址空间。

**逻辑地址**


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/59533072-5531-4107-b7c6-5f20e3bc7e61" /></div>
**页表**

**系统为每个进程建一张页表**，其在内存的起始地址和长度记录在该进程的PCB中。页表的每一行是一个页表项。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/afba25ae-a6a3-49e5-b02e-8232928d59bd" /></div>
**页表项长度**

每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/a1fad94a-ee4e-4421-97e1-eb7004253ca0" style="width:80%;"/></div>
<br>
### 地址变换


#### 普通地址变换


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/7dac4487-37f0-436c-a5b6-7d59d47be7b6" /></div>
$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。
每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。

#### 具有快表的地址变换

根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/4d110b83-5a36-468b-a971-57a6b99da83a" /></div>
#### 有效访问时间

设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。
- 普通地址变换时间：`t+t`
- 具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。

#### 两级页表

对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/9be850db-8e21-4a1d-8dbe-4a8d76194017" /></div>
**两级页表地址变换**


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/3ec51dd1-5b26-4d98-bfb5-18d567e4c164" /></div>
可推广至N级页表。

#### 反置页表

页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。
此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/3984a943-8925-44e0-b30d-b9aace27fe66" /></div>
<br>
## 分段存储管理方式

之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。

**方便编程**

通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。
```
LOAD 1，[A] |〈D〉；
STORE 1，[B] |〈C〉；
```

**信息共享**

在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。

**信息保护**

信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。

**动态增长**

在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。

**动态链接**

动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。 

<br>
### 分段地址


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/4a8347b6-2f86-4db6-99a4-7c8100267182" /></div>
#### 段表


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/0d0640e3-74c5-4d3d-8541-171c13c8e495" /></div>
#### 地址映射


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/e9f3f706-b819-440d-b3a4-f69756e1b5f7" /></div>
#### 地址变换


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/374a427d-4223-4e49-88e4-eb5563dd9fd4" /></div>
#### 分页和分段的主要区别

- 页是信息的物理单位，段则是信息的逻辑单位；
- 页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；
- 分页的地址空间是一维的，而分段的地址空间是二维的。
- 分页是系统管理的需要；分段是为了更好满足用户的需要。

<br>
## 段页式存储管理方式

分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。

<br>
### 原理

- 逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）
- 地址结构：段号，页号，页内偏移地址。
- 每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。

<br>
### 映射


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/d4ab1762-e6c8-4a13-8eea-e841c471df50" /></div>
<br>
### 地址变换机构


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/aaacf025-9204-4019-9bdc-18399f121b3a" /></div>
<br>
## 传统存储器的问题

传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：
- 大作业对内存的要求超出物理内存总容量，致使其无法运行。
- 内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。

<br>
### 解决原理


#### 程序局部性原理

1. 程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。
2. 过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。
3. 程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。
4. 程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。

**表现两个方面**

1. 时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。
2. 空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。

**基于局部性原理**

在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。

<br>
### 虚拟存储器定义

所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。

<br>
### 实现虚拟存储器的条件

由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：
- 页表（段表）的设计（软件支持）
- 程序不在内存时去外存调度需要中断（硬件支持）
- 逻辑地址转换为物理地址（软件硬件支持）
- 如何给每个进程分配物理块
- 一个页（段）进入内存时，淘汰哪个页（段）

<br>
## 请求分页存储管理方式


### 页表机制

用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/fa041bc8-d719-4aa7-9ba8-4baa6918ac91" /></div>
- 状态位（存在位）P：表示该页是否调入内存。
- 访问字段A：用于记录该页在某段时间内被访问的次数。
- 修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。
- 外存地址：该页在外存上的地址，通常是物理块号。

<br>
###  缺页中断机构

- 在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。
- 如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。
- 若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。
- 缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。

<br>
### 地址转换机构


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/b164ab99-02d0-494b-bb7f-f787c2613fc0" /></div>
<br>
### 内存分配


#### 最小物理块数的确定

最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。

#### 内存分配策略

在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置
换和局部置换（置换范围不同）。于是组合出三种适用的策略：
- 固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。
- 可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。
- 可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个较低的缺页率状态。

#### 物理块分配算法

- 平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。
- 按比例分配算法：按照进程的大小比例分配物理块。
- 考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。

<br>
### 页面调入


#### 何时调入页面

- 提前取页：预先装入主存一页或几页（提前页）。
- 请求取页：当用到某页而不在主存时即缺页时取页。

#### 从何处调入页面

外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：
- 系统有足够的对换空间：全部从对换区调入。
- 系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。
- UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。

#### 页面调入过程

1. 进程需要的页面不在内存，引起缺页中断
2. 中断处理程序保留现场环境，转入缺页中断处理程序
3. 中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。
4. 执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为`1`，并放入快表。
5. 利用修改后的页表，形成物理地址，访问内存数据。

#### 缺页率

- 假设进程逻辑空间为n页，系统为其分配物理块数为`m`。
- 如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数`A=S+F`，则进程运行过程中 缺页率`f=F/A`。
影响缺页率的主要因素：
- 页面大小：页面越大，缺页率越小
- 进程所分配物理块数：物理块越多，缺页率越小
- 页面置换算法：合理的置换算法能更少将页面调入调出
- 程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。

<br>
### 页面置换算法


#### 最佳置换算法

所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。
例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串
```
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```
进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/2979051c-7252-4c91-b6d5-2836841ad7be" /></div>
#### 先进先出页面置换算法

选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/6c79128c-993d-4689-8b24-c0ed1222742a" /></div>
#### 最近最久未使用置换算法

选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/f0576a05-7e3b-4c25-8f85-e23d186f6df5" /></div>
##### 硬件支持


**寄存器**

每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数
值最小的是最久未使用页面。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/8781a6ff-ee5c-4bd5-8c39-72bafb68e249" /></div>
**栈**

一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/deec2ffc-d896-4e78-bcaf-3f1d69815ac7" /></div>
#### 最少使用置换算法

选择到当前时间为止被访问次数最少的页面被置换。
- 实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。
- 实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。

####  Clock置换算法

也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。
内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。

#### 改进Clock置换算法

由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。
访问位A，修改位M有四种不同情形：
- 1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页
- 2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页
- 3类(A=1，M=0）被访问，但没有修改
- 4类(A=1，M=1）既被访问，又有修改
算法：
1. 指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。
2. 如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。
3. 如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。

#### 页面缓冲算法

在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：
- 页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。
- 写会磁盘的频率。
- 读入内存的频率。
而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：
- 空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。
- 修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。
当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。

<br>
### 访问内存的有效时间

- 被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$
  - 查找快表+访问实际物理地址
- 被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$
  - 查找快表+读取页表+读取数据+更新快表
- 被访问页不在主存：$EAT= \lambda + t + \varepsilon  + t + \lambda$
  - 查找快表+读取页表+缺页中断处理+读取数据+等新快表
- 内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$
  - `a`为命中率，`f`为缺页率。
  - 查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。

<br>
## 抖动与工作集


### 抖动

由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动"。
抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。

<br>
### 工作集

基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。
- 方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。
定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。
- 方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。
工作集$ \omega (t, \Delta) $是二元函数。某进程在时间`t`的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。

#### 例

- 窗口大小$\Delta$选择得过小，频繁产生缺页中断。
- 窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/58a68c04-867c-4616-836b-6442f8dc42dc" /></div>
<br>
### 抖动的预防方法

- 采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程
- 在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大
- `L=S`准则：`产生缺页的平均时间L=系统处理进程缺页的平均时间S`
- 选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间

<br>
##  请求分段存储管理方式

- 请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。
- 在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。
- 程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。
使用请求分段存储管理方式可以对动态链接有很好的支持。

<br>
### 请求段表机制


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/01222d76-e106-4c18-adc8-d19b9a59e4d6" /></div>
- 存取方式：标记本段存取属性。如读R，写W，执行X
- 访问字段A：记录本段使用的频繁程度
- 修改位：是否在调入内存后做过修改
- 存在位：本段是否装入内存
- 增补位：该段是否动态增长过

<br>
### 缺段中断机构

要有专门的缺段中断处理程序。特点：
- 指令和操作数必定不会跨越在段边界上。
- 由于段的长度是不固定的，处理比缺页系统复杂。
- 调入一个段可能要淘汰几个内存中的段。

<br>
### 请求中断处理


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/e70e650f-81ae-4000-b670-06c210adabd8" /></div>
<br>
### 地址中断机构


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/986886e7-0ca3-4c6c-a3ff-02082cee3a70" /></div>
<br>
### 分段的共享与保护


#### 共享段表


<div align='center'><img src="http://blogfileqiniu.isjinhao.site/6ff2d558-015d-4051-848b-74903bb4ef9f" /></div>
- 共享进程计数：多少进程在使用此段。
- 存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。
- 断号：同一个共享段在不同进程那有不同的断号。

#### 分配

第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置`count=1`； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做`count=count+1`，填写进程相关信息。

#### 回收

1. 做count=count-1；
2. 若count=0 ，则该共享段被回收。

#### 分段保护

- 越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。
- 存取控制检查：用于规定对该段的访问权限。通常的访问方式有：
  - 读：允许用户对该段/页内任何信息或其副本进行读操作。
  - 写：允许用户修改该段/页内任何信息直至撤消整个段/页。
  - 执行：用户可以执行该段/页程序，数据段/页除外。
  - 增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。
- 环保护检查：是一种功能较完善的保护机制。
  - 思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。
  - 操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。
  - 一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。
  - 一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。
