## 类之间的关系

在UML类图中，类之间的关系可以分成：关联（association）、聚合（aggregation）、组合（composition）、依赖（dependency）、泛化（generalization）/继承（inheritance）和实现（realization）。这六种关系如下图所描绘：

<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/23a267f9-4cad-4e40-9c56-0ee78ad6f267" /></div>
上面的关系可以解读如下：

- Association：A类有B类有逻辑上的连接
- Aggregation：A类有一个B类
- Composition：A类拥有一个B类
- Dependency：A类使用了B类
- Inheritance：B类是一个A类  (或者B类扩展A类)
- Realization：B类实现了接口A



### 六种类之间的关系

#### 关联

描述两个类之间行为的一般二元关系。例如，一个学生选修一门特定的课程是学生类Student和课程类Course之间的一个关联，而一个教师教授一门课程是师资类Faculty和课程类Course之间的一个关联。Java代码中，关联可以用属性和方法来实现。

```java
public class Student {
    private Course[] courses;   
    public void addCourse(Course s) {
        // . . . . . .
    }
}
public class Course {
    private Strudent[] students;
    private Faculty faculty;
    public void addStudent(Student s) {
        // . . . . . .
    }
    public void setFaculty(Faculty faculty) {
        this.faculty = faculty;
    }
}
public class Faculty {
    private Course[] courses;          
    public void addCourse(Course s) {
        // . . . . . .
    } 
}
```

#### 聚合

聚合是一种特殊的关联形式，表示两个对象之间的所属（has-a）关系。所有者对象称为聚合对象，它的类称为聚合类；从属对象称为被聚合对象，它的类称为被聚合类。例如，一个公司有很多员工就是公司类Company和员工类Employee之间的一种聚合关系。被聚合对象和聚合对象有着各自的生命周期，即如果公司倒闭并不影响员工的存在。

```java
public class Company {
    private List<Employee> employees;
}
public class Employee {
    private String name;   
}
```

#### 组合

聚合是一种较弱形式的对象包含（一个对象包含另一个对象）关系，较强形式是组合（Composition）。在组合关系中包含对象负责被包含对象的创建以及生命周期，即当包含对象被销毁时被包含对象也会不复存在。例如人的头和人的嘴。

```java
public class Head {
    private Mouth mouth;
    public Head() {
        mouth = new Mouth();
    }
}
public class Mouth { }
```

#### 依赖

依赖关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。

```java
public class Driver {
    public void drive(Car car) {
        car.move();
    }
}
public class Car {
    public void move() {
        // ....
    }
}
```

依赖关系有如下三种情况：

- A类是B类中的（某中方法的）局部变量；
- A类是B类方法当中的一个参数；
- A类向B类发送消息，从而影响B类发生变化；

##### 辨析

以上四类关系中，依赖是最好与其他三种区分的。其他三种都是通过类的属性与其他类进行关联，而依赖是通过方法与其他类进行关联。

- 关联：对象有独立的生命周期，而且对象之间没有所属关系。
- 聚合：对象有独立的生命周期，但是有所属关系。比如公司和员工是上下级关系。
- 组合：有所属关系，但是对象没有独立的生命周期，比如人的脸和嘴的生命周期是一致的。

##### 泛化/继承

模拟两个类之间的is-a关系。**强是**（strong is-a）关系描述两个类之间的继承关系。**弱是**（weak is-a）关系描述一个类具有某个属性。强是关系可以用类的继承表示。例如，Spring的ApplicationEvent是一个EventObject，ApplicationEvent和EventObject间就是一种强是关系，可以用继承描述。

```java
public abstract class ApplicationEvent extends EventObject {
    // . . . . . .
}
```

##### 实现

描述的是一个类实现了接口（可以是多个）。上面描述的弱是(weak is-a)关系就可以用接口表示。例如字符串是可以被序列化的，这就可以用实现来描述。

```java
public final class String 
	implements java.io.Serializable, Comparable<String>, CharSequence{
    // . . . . . .
}
```



### 案例

```java
public class Department {
    private Person[] people;
    private Integer did;
    private String name;
	// getter and setter
}
```

```java
public class IDCard { }
```

```java
public class Person {
    private IDCard idCard;
    private Department department;
	// getter and setter
}
```

```java
public class PersonDao {
    public void save() { }
    public Person getPerson() {
        return new Person();
    }
    public void modifyDepartment(Integer personid, Department department) {	}
}
```

```java
public interface PersonServiceInterface {
    void save(Person person);
    IDCard getIDCard(Integer personid);
    void setNullDepartment(Integer personid);
}
```

```java
public class PersonService implements PersonServiceInterface{
    private PersonDao personDao = new PersonDao();    // 类
    @Override
    public void save(Person person) {
        personDao.save();
    }
    @Override
    public IDCard getIDCard(Integer personid) {
        return personDao.getPerson().getIdCard();
    }
    @Override
    public void setNullDepartment(Integer personid) {
        Department department = new Department();
        personDao.modifyDepartment(personid, department);
    }
}
```

```java
public class OldPersonService extends PersonService { }
```

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/4f5be664-4370-44ba-b15d-19475e66bac1" /></div>


## 常见的面向对象难点





## 设计模式七大原则

### 接口隔离原则

The **interface-segregation principle** (**ISP**) states that no client should be forced to depend on methods it does not use. ISP splits interfaces that are very large into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them. Such shrunken interfaces are also called *role interface*s. ISP is intended to keep a system decoupled and thus easier to refactor, change, and redeploy.

**不遵循ISP的实现**

```java
// 接口
interface Interface1 {
	void operation1();
	void operation2();
	void operation3();
	void operation4();
	void operation5();
}

class B implements Interface1 {
	public void operation1() {
		System.out.println("B 实现了 operation1");
	}
	public void operation2() {
		System.out.println("B 实现了 operation2");
	}
	public void operation3() {
		System.out.println("B 实现了 operation3");
	}
	public void operation4() {
		System.out.println("B 实现了 operation4");
	}
	public void operation5() {
		System.out.println("B 实现了 operation5");
	}
}

class D implements Interface1 {
	public void operation1() {
		System.out.println("D 实现了 operation1");
	}
	
	public void operation2() {
		System.out.println("D 实现了 operation2");
	}
	public void operation3() {
		System.out.println("D 实现了 operation3");
	}
	public void operation4() {
		System.out.println("D 实现了 operation4");
	}
	public void operation5() {
		System.out.println("D 实现了 operation5");
	}
}

class A { // A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend2(Interface1 i) {
		i.operation2();
	}
	public void depend3(Interface1 i) {
		i.operation3();
	}
}
  
class C { // C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend4(Interface1 i) {
		i.operation4();
	}
	public void depend5(Interface1 i) {
		i.operation5();
	}
}
```

**遵循ISP的实现**

```java
// 接口1
interface Interface1 {
	void operation1();
}

// 接口2
interface Interface2 {
	void operation2();
	void operation3();
}

// 接口3
interface Interface3 {
	void operation4();
	void operation5();
}

class B implements Interface1, Interface2 {
	public void operation1() {
		System.out.println("B 实现了 operation1");
	}
	public void operation2() {
		System.out.println("B 实现了 operation2");
	}
	public void operation3() {
		System.out.println("B 实现了 operation3");
	}
}

class D implements Interface1, Interface3 {
	public void operation1() {
		System.out.println("D 实现了 operation1");
	}
	public void operation4() {
		System.out.println("D 实现了 operation4");
	}
	public void operation5() {
		System.out.println("D 实现了 operation5");
	}
}

class A { // A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend2(Interface2 i) {
		i.operation2();
	}
	public void depend3(Interface2 i) {
		i.operation3();
	}
}

class C { // C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法
	public void depend1(Interface1 i) {
		i.operation1();
	}
	public void depend4(Interface3 i) {
		i.operation4();
	}
	public void depend5(Interface3 i) {
		i.operation5();
	}
}
```



### 依赖倒置原则

1. High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces).
2. Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.

如下图便是不遵循DIP的雨来方式，高层模块直接依赖了低层模块。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/b73053b6-a45e-40f4-94c0-f7c790c0b27d" /></div>
修改以上的结构，让上层模块依赖下层模块的接口，如下图所示。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/77dbbb25-f8e2-4d8b-8acb-85489a5bbf4a" /></div>

**依赖倒置的好处**

在Java6以及之前的JDK版本中，有一个非常讨厌的问题，那就是在使用了OutputStream或者其他可关闭的对象之后，我们必须保证它们最终被关闭了，于是就有这样的代码：

```java
public void put(String url,Bitmap bitmap) {

    FileOutputStream out = null;
    try {
        out = new FileOutputStream(CACHE_DIR + url);
       	// ...
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (out != null) {
            try {
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

这段代码的可读性非常差，各种try...catch嵌套的都是简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。

但是Java中有一个Closeable接口，该接口标识了一个可关闭的对象，它只有一个close方法，我们要讲的FileOutputStream类就实现类就实现了这个接口，实际上还有100多个类实现了这还接口，这意味着，在关闭着100多个类型的对象时，都需要写出像put方法中finally代码段那样的代码。这是非常让人痛苦的，所以我们要把这个问题变得简单，既然都是实现了Closeable接口，那只要我建一个方法统一来关闭这些对象不就可以了吗，于是我们开始写下如下的工具类：

```java
public class CloseUtils {
    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```



### 单一职责原则

The single-responsibility principle (SRP) is a computer-programming principle that states that every module  or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class, module or function. All its services should be narrowly aligned with that responsibility. Robert C. Martin expresses the principle as, "A class should have only one reason to change.".

**不遵循SRP的实现**

```java
public class SingleResponsibility1 {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Vehicle vehicle = new Vehicle();
        vehicle.run("摩托车");
        vehicle.run("汽车");
        vehicle.run("飞机");
    }
}

class Vehicle {
    public void run(String vehicle) {
        if ("摩托车".equals(vehicle) || "汽车".equals(vehicle))
            System.out.println(vehicle + "在公路跑....");
        else if ("飞机".equals(vehicle)) {
            System.out.println(vehicle + "在天空飞....");
        }
    }
}
```

上面的实现中，类Vehicle负责了多个职责，包括交通工具的名称（摩托车、汽车、飞机）、运行的地方（公路、天空）、运行的方式（跑、飞）。所以我们可以按照单一职责原则对其进行分解。

**遵循SRP的实现**

```java
public class SingleResponsibility2 {
    public static void main(String[] args) {
        VehicleExecutor vehicleExecutor = new VehicleExecutor();
        vehicleExecutor.run(new Moto(), new Road(), new Run());
        vehicleExecutor.run(new Car(), new Road(), new Run());
        vehicleExecutor.run(new Airplane(), new Sky(), new Fly());
    }
}

class VehicleExecutor {
    public void run(Who who, Where where, What what) {
        System.out.println(who.who() + "在" + where.where() + "上 " + what.what());
    }
}

interface Who {
    String who();
}

class Moto implements Who {
    @Override
    public String who() {
        return "摩托车";
    }
}

class Car implements Who {
    @Override
    public String who() {
        return "汽车";
    }
}

class Airplane implements Who {
    @Override
    public String who() {
        return "飞机";
    }
}

interface Where {
    String where();
}

class Road implements Where {
    @Override
    public String where() {
        return "路上";
    }
}

class Sky implements Where {
    @Override
    public String where() {
        return "天空";
    }
}

interface What {
    String what();
}

class Fly implements What {
    @Override
    public String what() {
        return "飞";
    }
}

class Run implements What {
    @Override
    public String what() {
        return "跑";
    }
}
```

可以看到，按照SRP实现的代码将交通工具的名称、运行的地方、运行的方式给分离开了。其实遵循SRP并不是将类的职责划分的越小越好，这取决于项目的大小以及迭代的情况，比如基本不会迭代的项目，划分的太细，反而给开发者增加了很大工作量。



### 里氏替换原则

The liskov substitution principle is a principle in object-oriented programming stating that, in a computer program, if S is a subtype of T, then objects of type T may be *replaced* with objects of type S (i.e. an object of type T may be *substituted* with any object of a subtype S) without altering any of the desirable properties of the program (correctness, task performed, etc.).

