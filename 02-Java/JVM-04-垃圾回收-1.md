<br>

## Reference

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/b54bdcf1-1eda-42ce-a0a6-ec4f5b4ee1ee" /></div>
**强引用**

Java中默认声明的就是强引用，比如：

```java
Object obj = new Object(); // 只要obj还指向Object对象，Object对象就不会被回收
obj = null;  // 手动置null
```

只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，也不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。

**软引用**

软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。表示软引用的类是java.lang.ref.SoftReference。下面以一个例子来进一步说明强引用和软引用的区别：
首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常：

```java
//  -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。
public class TestOOM {
    public static void main(String[] args) {
         testStrongReference();
    }
    private static void testStrongReference() {
        // 当 new byte为 1M 时，程序运行正常
        // 当 new byte为 1M 时，程序报异常 OutOfMemoryError
        byte[] buff = new byte[1024 * 1024 * 3];
    }
}

```

接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。

```java
public class TestOOM {
    private static List<Object> list = new ArrayList<>();
    public static void main(String[] args) {
        testSoftReference();
    }
    private static void testSoftReference() {
        for (int i = 0; i < 5; i++) {
            SoftReference<byte[]> sr = new SoftReference<>(new byte[1024 * 1024]);
            list.add(sr);
        }
        for(int i=0; i < 5; i++){
            Object obj = ((SoftReference) list.get(i)).get();
            System.out.println(obj);
        }
    }
}
/*
    null
    null
    null
    null
    [B@12a3a380
*/

```

我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。

**弱引用**

弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。

```java
private static void testWeakReference() {
    for (int i = 0; i < 5; i++) {
        WeakReference<byte[]> sr = new WeakReference<>(new byte[1024 * 1024]);
        list.add(sr);
    }
    System.gc(); //主动通知垃圾回收
    for(int i=0; i < 5; i++){
        Object obj = ((WeakReference) list.get(i)).get();
        System.out.println(obj);
    }
}
/*
    null
    null
    null
    null
    null
*/

```

可以发现所有被弱引用关联的对象都被垃圾回收了。

**虚引用**

虚引用并不会影响对象的生命周期。虚引用的作用为：跟踪垃圾回收器收集对象这一活动的情况。当GC一旦发现了虚引用对象，则会将PhantomReference对象插入ReferenceQueue队列，而此时PhantomReference对象并没有被垃圾回收器回收，而是要等到ReferenceQueue被你真正的处理后才会被回收。
注意：PhantomReference必须要和ReferenceQueue联合使用，SoftReference和WeakReference可以选择和ReferenceQueue联合使用也可以不选择。

<br>

### ReferenceQueue

```java
public class RefTest {
    private static ReferenceQueue<byte[]> rq = new ReferenceQueue<>();
    private static int _1M = 1024 * 1024;
    public static void main(String[] args) {
        Object value = new Object();
        Map<Object, Object> map = new HashMap<>();
        Thread thread = new Thread(() -> {
            try {
                int cnt = 0;
                PhantomReference<byte[]> k;
                // Removes the next reference object in this queue
                // blocking until one becomes available.
                while ((k = (PhantomReference<byte[]>) rq.remove()) != null) {
                    System.out.println((cnt++) + "回收了: " + k);
                }
            } catch (InterruptedException e) {
                //结束循环
            }
        });
        thread.setDaemon(true);
        thread.start();
        for (int i = 0; i < 10; i++) {
            byte[] bytes = new byte[_1M];
            PhantomReference<byte[]> weakReference = new PhantomReference<>(bytes, rq);
            map.put(weakReference, value);
        }
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("gc........");
        System.gc();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

先输出6次表示在加入第6个加入后触发了GC操作，然后在停住的5秒里没有任何操作表示没有触发GC，所以不会加入到队列中，然后我们手动触发一次GC，对象都被加入到队列中了。

<br>

### System.gc()

> Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects.
> The name gc stands for "garbage collector". The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the gc method is not invoked explicitly.
> The method System.gc() is the conventional and convenient means of invoking this method.



## 对象已死吗

### 对象判死算法

**引用计数器**

给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但这种计数法无法解决循环引用的问题，即若A对象中有属性B，B对象中有属性A，则A、B永远都有计数。



**可达性分析算法**

通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/beb26a0b-591a-4948-a999-ba5f3fac2abe" style="width:80%;" /></div>
在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象



### 生存还是死亡

即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过**两次标记过程**：

如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行`finalize()`方法，"没有必要执行"的原因如下：当对象没有覆盖`finalize()`方法，或者`finalize()`已经被JVM调用过（说明一个对象的`finalize()`方法只能执行一次）。如果这个对象有必要执行`finalize()`方法，JVM就会把它放在`F-Queue`中，稍后`JVM`会触发一个低优先级的线程去执行。但是去执行并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。`finalize()`是对象逃脱死亡命运的最后一次机会，稍后`GC`将会对`F-Queue`进行第二次小规模的标记，如果在`finalize()`中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。

不过非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，Java程序员完全可以忘掉Java有finalize()。

`finalize()`测试：

```java
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;
    public void isAlive() {
        System.out.println("haha, i'm still alive!");
    }
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次拯救自己
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("5555, i'm dead!");
        }
        //对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if(SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("5555, i'm dead!");
        }
    }
}
/*output:
    finalize method executed!
    haha, i'm still alive!
    5555, i'm dead!
*/
```



### 回收方法区

永久代的垃圾收集主要回收两部分内容：

- 废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。
- 无用的类：判断一个类是无用的类的条件比废弃变量要苛刻的多，要同时满足3个条件才能算是“无用的类”：
  1. 该类所有的实例都已经被回收，意思是堆上没有该对象的实例了
  2. 加载该类的ClassLoader已经被回收。
  3. 该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



## 基本垃圾收集算法

**标记-清除算法**

首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高，因为当对象数量比较多的时候一一进行标记和清除较复杂；二是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触发垃圾回收操作。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/afb85c53-8df7-4dc6-b0bf-fd1f5c49390e" style="width:60%;" /></div>
**复制算法**

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ca3dd6f1-6e7b-4109-80d6-bf5532ddaaaa" /></div>
**标记整理算法**

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/44deb98c-fc46-4385-b972-2a65b5212def" /></div>
**分代收集算法**

当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。

在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。

同时IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。**HotSpot虚拟机默认Eden和Survivor的大小比例是8：1**，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用老年代进行分配担保。



## 内存分配与回收策略

**Minor GC 和 Full GC**

- Minor GC：发生在新生代的GC。触发条件：当Eden区满时。
- Full GC（也叫Major GC）：发生在老年代的GC，通常会触发Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。触发条件：
  - 调用System.gc()时，系统建议执行Full GC，但是不必然执行
  - 老年代空间不足
  - 方法区空间不足
  - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
  - 由Eden区、From Survivor区向To Survivor区复制时，对象大小大于To Survivor可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

**对象优先在Eden分配**

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

**大对象直接进入老年代**

所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。

虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。

**长期存活的对象将进入老年代**

虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。

**动态对象年龄判定**

虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

**空间分配担保**

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进程一次Minor GC（尽管此次GC是有风险的），如果小于或者不允许冒险，需要进行一次Full GC。

在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。



## 可达性算法的实现

**枚举根节点**

### 枚举根节点

在 GC Roots节点找引用链这个操作的过程中，可作为 GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。

另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行。这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，否则分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中。枚举根节点时也是必须要停顿的。

**OopMap**

垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。

一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 GC 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。

**安全点**

我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面有多个指令。但是HotSpot没有为每条指令都生成OopMap，那样占用空间太多，而只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）。引入安全点之后，程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

GC 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（GC Roots）。

另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：**抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）**，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

**安全区域**

如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。

在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。



## 基本垃圾收集器

在JDK8中默认的垃圾收集算法仍然是分代的算法。同时上文中的提到的垃圾收集算法会应用在不同的业务场景中。不过在JDK9以至于后续的JDK版本，G1是默认的垃圾收集器，这个会在下一篇文章中单独解释。

下图中的CMS垃圾收集器使用的不是简单的使用我们上面介绍的垃圾收集算法。关于它会在本文的后续介绍。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/5ffa2bc8-c126-46b2-a9e3-88e1ffa37a0d" style="width:60%;" /></div>
### Serial / Serial Old

Serial 收集器是一个使用“复制”算法的新生代单线程收集器。它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。不过在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。所以其主要的运行在Client端。

Serial Old 收集器是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记一整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。

下图是Serial / Serial Old 配合工作时的图。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/29dab41d-2290-41bb-b8c0-3f36f91e3bd1" style="width:80%;" /></div>
### ParNew

ParNew 本质上就是Serial收集器的多线程版本，所以单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用`-XX:ParallelGCThreads`参数来限制收集器的线程数。

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/05dacdd7-3318-4c92-8f35-9d24b0cbabb9" /></div>
### Parallel Scavenge / Parallel Old

Parallel Scavenge也是一个新生代收集器，它也是使用复制算法的收集器，同时也是并行的多线程收集器。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。

这就说说一下应用场景了。

- 停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验
- 高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务

为了这两个目的，Parallel Scavenge收集器提供了2个参数：

- `-XX:MaxGCPauseMillis`：大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。
- `-XX:GCTimeRatio`：大于0小于100的整数。假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N)，比如设置为19，占比就是1/(1+19)=5%，默认值是99，即1%。
- `-XX:+UseAdaptiveSizePolicy`：这是一个很有用的参数。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（`-Xmn`）、Eden、Survivor区的比例（`-XX:SurvivorRatio`）、晋升老年代对象年龄（`-XX:PretenureSizeThreshold`）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（`GC Ergonomics`）。自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别。

Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，并非直接使用了Serial Old收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近，所以我们可以认为Parallel Scavenge默认搭配Serial Old运行。

Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK6之后才提供的。由于Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到 JDK6 推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，**在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合**。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/350ae90f-6b11-4855-af56-8d11ff726239" style="width:80%;" /></div>
## 案例分析

**查看当前虚拟机信息**

```
java -XX:+PrintCommandLineFlags -version
-XX:InitialHeapSize=116435136 -XX:MaxHeapSize=1862962176 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
java version "1.8.0_221"
Java(TM) SE Runtime Environment (build 1.8.0_221-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)
```

- -XX:InitialHeapSize：初始化的堆大小
- -XX:MaxHeapSize：最大的堆大小
- -XX:+UseParallelGC：使用ParNew和Par
- -XX:+PrintCommandLineFlags：打印虚拟机启动参数

- 剩下的三个参数和GC无关。



**Minor GC**

```java
/*
  -verbose:gc 输出冗余的gc信息
  -Xms20M 堆初始化大最小容量
  -Xmx20M 堆初始化最大容量
  -Xmn10M 新生代容量
  -XX:+PrintGCDetails
  -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1
  */

public static void main(String[] args) {
    int _1M = 1024 * 1024;
    byte[] bytes1 = new byte[2 * _1M];
    byte[] bytes2 = new byte[2 * _1M];
    System.out.println("============");
    byte[] bytes3 = new byte[3 * _1M];	// 此时发送Minor GC
    System.out.println("============");
    byte[] bytes4 = new byte[4 * _1M];
    System.out.println("hello world");
}
```

```
============
[GC (Allocation Failure) [PSYoungGen: 5758K->792K(9216K)] 5758K->4896K(19456K), 0.0027827 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
============
hello world
Heap
 PSYoungGen      total 9216K, used 8283K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd50da8,0x00000000ffe00000)
  from space 1024K, 77% used [0x00000000ffe00000,0x00000000ffec6030,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 4104K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff002020,0x00000000ff600000)
 Metaspace       used 3101K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 335K, capacity 388K, committed 512K, reserved 1048576K
```

`GC (Allocation Failure)`：本次GC是Minor GC，GC的原因是分配失败。

`[PSYoungGen: 5758K->792K(9216K)]`：新生代使用的是Parallel Scavenge收集器。9216K表示新生代可用空间是9216K，也就是9M，因为新生代的Eden空间是9M，From Survior是1M。To Survior是被浪费的。这部分空间的减少包含晋升到老年代的和真正被清除的。

`5758K->4896K(19456K)`：19456K表示总的可用的空间是19M，还是由于To Survior是被浪费的。这部分空间的减少是真正被清除的垃圾。

`0.0027827 secs`：本次GC的时间，单位秒。

`ParOldGen       total 10240K, used 4104K`：(5758K-792K)-(5758K-4896K)=4014K。老年代使用Serial Old。

**Full GC**

```java
/*
  -verbose:gc 输出冗余的gc信息
  -Xms20M 堆初始化大最小容量
  -Xmx20M 堆初始化最大容量
  -Xmn10M 新生代容量
  -XX:+PrintGCDetails
  -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1
  */
public static void main(String[] args) {
    int _1M = 1024 * 1024;
    byte[] bytes1 = new byte[2 * _1M];
    byte[] bytes2 = new byte[3 * _1M];
    System.out.println("============");
    byte[] bytes3 = new byte[3 * _1M];	// Minor GC 和 Full GC
    System.out.println("============");
    byte[] bytes4 = new byte[4 * _1M];
    System.out.println("hello world");
}
```

```
============
[GC (Allocation Failure) [PSYoungGen: 6946K->792K(9216K)] 6946K->5920K(19456K), 0.0031393 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Ergonomics) [PSYoungGen: 792K->0K(9216K)] [ParOldGen: 5128K->5739K(10240K)] 5920K->5739K(19456K), [Metaspace: 3117K->3117K(1056768K)], 0.0064401 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
============
hello world
Heap
 PSYoungGen      total 9216K, used 7492K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd510d8,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 5739K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff19ae28,0x00000000ff600000)
 Metaspace       used 3133K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K
```

`[ParOldGen: 5128K->5739K(10240K)]`：老年代使用的是Serial Old收集器。

**大对象直接在老年代分配**

```java
/*
 -verbose:gc 输出冗余的gc信息
 -Xms20M 堆初始化大最小容量
 -Xmx20M 堆初始化最大容量
 -Xmn10M 新生代容量
 -XX:+PrintGCDetails
 -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1
 -XX:PretenureSizeThreshold=4194304 设置对象超过多大时直接分配到老年代，单位B。
 				需要和UseSerialGC一起使用
 -XX:+UseSerialGC 表示指定垃圾收集器为SerialGC
 */
public static void main(String[] args) {
    int _1M = 1024 * 1024;
    byte[] bytes1 = new byte[7 * _1M];
}
```

```
Heap
 def new generation   total 9216K, used 1990K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  24% used [0x00000000fec00000, 0x00000000fedf1b58, 0x00000000ff400000)
  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 tenured generation   total 10240K, used 7168K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
   the space 10240K,  70% used [0x00000000ff600000, 0x00000000ffd00010, 0x00000000ffd00200, 0x0000000100000000)
 Metaspace       used 3164K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 342K, capacity 388K, committed 512K, reserved 1048576K
```

`def new generation`：新生代使用的是Serial收集器

`tenured generation`：老年代使用的是Serial old收集器

没有发生GC，说明大对象直接在老年代分配了

**晋升到老年代的对象年龄管理**

```java
//-verbose:gc
//-Xmx200M
//-Xms200M
//-Xmn50M
//-XX:SurvivorRatio=8
//-XX:TargetSurvivorRatio=60
//-XX:+PrintTenuringDistribution
//-XX:+PrintGCDetails
//-XX:+PrintGCDateStamps
//-XX:+UseConcMarkSweepGC
//-XX:+UseParNewGC      TargetSurvivorRatio参数需要配合ParNew收集器使用
//-XX:MaxTenuringThreshold=3
public static void main(String[] args) throws InterruptedException {
    byte[] bytes1 = new byte[512 * 1024];
    byte[] bytes2 = new byte[512 * 1024];

    allocation();
    System.out.println("11111111");

    allocation();
    System.out.println("22222222");

    allocation();
    System.out.println("33333333");

    allocation();
    System.out.println("44444444");

    byte[] bytes3 = new byte[1024 * 1024];
    byte[] bytes4 = new byte[1024 * 1024];
    byte[] bytes5 = new byte[1024 * 1024];

    allocation();
    System.out.println("55555555");

    allocation();
    System.out.println("66666666");
}

public static void allocation() {
    for (int i = 0; i < 40; i++) {
        byte[] bytes = new byte[1024 * 1024];
    }
}
```

```
2019-12-30T11:22:31.926+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.926+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 3 (max 3)
- age   1:    1716192 bytes,    1716192 total
: 40355K->1713K(46080K), 0.0011085 secs] 40355K->1713K(199680K), 0.0011876 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
11111111
2019-12-30T11:22:31.930+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.930+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 3 (max 3)
- age   1:        232 bytes,        232 total
- age   2:    1701976 bytes,    1702208 total
: 42452K->1923K(46080K), 0.0010934 secs] 42452K->1923K(199680K), 0.0011384 secs] [Times: user=0.06 sys=0.03, real=0.00 secs] 
22222222
2019-12-30T11:22:31.933+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.934+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 3 (max 3)
- age   1:         56 bytes,         56 total
- age   2:        232 bytes,        288 total
- age   3:    1701000 bytes,    1701288 total
: 42454K->1900K(46080K), 0.0006981 secs] 42454K->1900K(199680K), 0.0007424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
33333333
2019-12-30T11:22:31.936+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.936+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 3 (max 3)
- age   1:         56 bytes,         56 total
- age   2:         56 bytes,        112 total
- age   3:        232 bytes,        344 total
: 42632K->279K(46080K), 0.0023449 secs] 42632K->1960K(199680K), 0.0023807 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
44444444
2019-12-30T11:22:31.942+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.942+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 1 (max 3)
- age   1:    3145832 bytes,    3145832 total
- age   2:         56 bytes,    3145888 total
- age   3:         56 bytes,    3145944 total
: 41013K->3124K(46080K), 0.0014786 secs] 42695K->4806K(199680K), 0.0015408 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
55555555
2019-12-30T11:22:31.946+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.946+0800: [ParNew
Desired survivor size 3145728 bytes, new threshold 3 (max 3)
- age   1:         56 bytes,         56 total
: 43860K->8K(46080K), 0.0021793 secs] 45542K->4762K(199680K), 0.0022246 secs] [Times: user=0.05 sys=0.01, real=0.00 secs] 
66666666
Heap
 par new generation   total 46080K, used 14941K [0x00000000f3800000, 0x00000000f6a00000, 0x00000000f6a00000)
  eden space 40960K,  36% used [0x00000000f3800000, 0x00000000f46952a8, 0x00000000f6000000)
  from space 5120K,   0% used [0x00000000f6000000, 0x00000000f60022e0, 0x00000000f6500000)
  to   space 5120K,   0% used [0x00000000f6500000, 0x00000000f6500000, 0x00000000f6a00000)
 concurrent mark-sweep generation total 153600K, used 4754K [0x00000000f6a00000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K
```

`Desired survivor size 3145728 bytes`：当Survivor的已空间小于大于时，重新计算`MaxTenuringThreshold`。

`33333333`：这行输出之前，我们可以看见Survivor空间里面有对象年龄在增长。

`44444444`：这行输出之前的GC，将部分的Survior里的对象晋升到老年代了

`55555555`：这行输出之前的GC，三个年龄的对象大小加一起已经超过3145728了，所以，此时重新计算`MaxTenuringThreshold`。由于计算得到的是1，所以全部的Survivor里的对象都会晋升到老年代。

`66666666`：可以发现现在的Survivor里只有1岁的对象了。



## CMS收集器

Comcurrent Mark Sweep。CMS收集器是以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求。

从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：

1. 初始标记：初始标记仅仅只是标记一下 GC roots 能直接关联到的对象，速度很快，需要stop the world。
2. 并发标记：并发标记就是进行GC Roots Tracing（可达性算法）的过程。
3. 重新标记：重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短，需要stop the world。
4. 并发清除：垃圾清除。

<div align='center'><img src="http://blogfileqiniu.isjinhao.site/a504f382-d97e-496b-aeae-247c962d2081" style="width:80%;" /></div>
由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

从CMS收集器执行的过程来看。初始标记只标记能被直接关联到的对象，在并发标记的时候才使用可达性算法去寻找全部的存活的对象。而后在重新标记阶段去修改将并发过程中新出现的引用或者失效的引用。如果在并发标记过程中，有大量的引用状态发生改变，重新标记阶段就会导致长时间的STW。所以CMS用于老年代。

CMS收集器的优点在于并发收集、低停顿，但是也不是完美的，主要有3个显著的缺点：

1. CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。
2. CMS收集器无法处理浮动垃圾（Float Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。参数-XX:CMSInitiatingOccupancyFraction的值可以控制这个空间的大小。值越大，内存回收次数越少，从而性能更高。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old
   收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说此参数若设置得太高很容易导致大量“Concurrent Mode Failure“，性能反而降低。
3. CMS是基于标记-清除算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有STW了。同时虚拟机还有参数-XX:CMSFullGCsBeforeCompaction，用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。



### CMS运行过程详细划分

#### 标记过程

**Initial Mark**

标记那些直接被GC roots引用或者被年轻代存活对象所引用的所有对象。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ecc16ffc-a82d-4f44-a417-3bfc97d5fece" /></div>
**Concurrent Mark**

在这个阶段 Garbage Collector 会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到的 GC Roots 遍历查找。并发标记阶段，它会与用户的应用程序并发运行。并不是Initial Mark阶段的老年代的所有存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/8c714b9a-7e02-42b0-9492-5beb30160ef0" /></div>
**Concurrent Preclean**

这也是一个并发阶段，与应用的线程并发运行，并不会stop应用的线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM会将包含这个对象的区域（Card）标记为 Dirty ，被称为 Card Marking。

在pre -clean-阶段，那些能够从 Dirty 对象到达的对象也会被标记，这个标记做完之后，Dirty Card标记就会被清除了。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/dd07b39c-81d8-4a62-b078-58f6be5ae04c" /></div>
<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/0931dd94-52d7-4c2b-ac07-0e0120d7a143" /></div>
**Concurrent Abortable Preclean**

又一个并发阶段不会停止应用程序线程。这个阶段尝试着去承担 STW 的 Final Remark 阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生 aboart 的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。

**Final Remark**

这个阶段是CMS中第二个并且是最后一个STW的阶段。该阶段的任务是完成标记整个年老代的所有的存活对象。由于之前的预处理是并发的，它可能跟不上应用程序改变的速度，这个时候，STW是非常需要的来完成这个严酷考验的阶段。

通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候，目的是消除紧接着的连续的几个 STW 阶段。因为年轻代存活对象过多的话，Minor GC会引发Full GC。

**Concurrent Sweep**

和应用线程同时进行，不需要STW。这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。

<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ccd6905d-eb71-496d-a306-b1fff1b5fd8a" /></div>
**Concurrent Reset**

这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。



### 案例

```java
//-verbose:gc
//-Xms20M
//-Xmx20M
//-Xmn10M
//-XX:+PrintGCDetails
//-XX:SurvivorRatio=8
//-XX:+UseConcMarkSweepGC
public static void main(String[] args) {
    int _1M = 1024 * 1024;
    byte[] bytes1 = new byte[4 * _1M];
    System.out.println("----------------111111----------------");

    byte[] bytes2 = new byte[4 * _1M];
    System.out.println("----------------222222----------------");

    byte[] bytes3 = new byte[4 * _1M];
    System.out.println("----------------333333----------------");

    byte[] bytes4 = new byte[2 * _1M];
    System.out.println("----------------444444----------------");
}
```

```
----------------111111----------------
[GC (Allocation Failure) [ParNew: 5922K->682K(9216K), 0.0026537 secs] 5922K->4780K(19456K), 0.0027242 secs] [Times: user=0.11 sys=0.02, real=0.00 secs] 
----------------222222----------------
[GC (Allocation Failure) [ParNew: 5019K->186K(9216K), 0.0041525 secs] 9117K->9008K(19456K), 0.0042047 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (CMS Initial Mark) [1 CMS-initial-mark: 8821K(10240K)] 13159K(19456K), 0.0002459 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-mark-start]
----------------333333----------------
----------------444444----------------
[CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-preclean-start]
[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-abortable-preclean-start]
[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (CMS Final Remark) [YG occupancy: 7648 K (9216 K)][Rescan (parallel) , 0.0006080 secs][weak refs processing, 0.0000306 secs][class unloading, 0.0004074 secs][scrub symbol table, 0.0006653 secs][scrub string table, 0.0001587 secs][1 CMS-remark: 8821K(10240K)] 16470K(19456K), 0.0019851 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-sweep-start]
[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-reset-start]
[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 7812K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  eden space 8192K,  93% used [0x00000000fec00000, 0x00000000ff3729b8, 0x00000000ff400000)
  from space 1024K,  18% used [0x00000000ff400000, 0x00000000ff42e950, 0x00000000ff500000)
  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
 concurrent mark-sweep generation total 10240K, used 8820K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 3193K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 343K, capacity 388K, committed 512K, reserved 1048576K
```

`222222`：分配第二个4M空间时进行Minor GC。

`333333`：分配第三个4M空间时会进行Minor GC。然后跟着CMS GC。我们可以发现CMS在工作的时候出现的不是Full GC。可能是由于Oracle认为GC只会STW很短的一段时间，所以不算为Full GC。

我们从上面的GC日志可以看到七个阶段。其中`CMS Initial Mark`和`CMS Final Remark`会出现在GC阶段，说明他们需要STW，而其他的五个阶段是和用户线程并行的。



## 常用的参数

|              参数              |                             描述                             |
| :----------------------------: | :----------------------------------------------------------: |
|          UseSerialGC           | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收 |
|          UseParNewGC           | 打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收  |
|       UseConcMarkSweepGC       | 打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用 |
|         UseParallelGC          | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收 |
|        UseParallelOldGC        | 打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收 |
|         SurvivorRatio          | 新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor:Survivor=8:1:1 |
|     PretenureSizeThreshold     | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配（只对串行回收器和ParNew有效） |
|      MaxTenuringThreshold      | 晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代（只对串行回收器和ParNew有效） |
|     UseAdaptiveSizePolicy      |      动态调整Java堆中各个区域的大小以及进入老年代的年龄      |
|     HandlePromotionFailure     | 是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
|       ParallelGCThreads        |               设置并行GC时进行内存回收的线程数               |
|          GCTimeRatio           | GC时间占总时间的比率，默认值为99，即允许1%的GC时间（仅在使用Parallel Scavenge收集器时生效） |
|        MaxGCPauseMillis        | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效  |
| CMSinitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效 |
|   CMSFullGCsBeforeCompaction   | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效 |
