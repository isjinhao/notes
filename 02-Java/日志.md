## 日志技术

**日志文件**

日志文件是用于记录系统操作事件的文件集合，可分为事件日志和消息日志。具有处理历史数据、诊断问题的追踪以及理解系统的活动等重要作用。

在计算机中，日志文件是记录在操作系统或其他软件运行中发生的事件或在通信软件的不同用户之间的消息的文件。记录是保持日志的行为。在最简单的情况下，消息被写入单个日志文件。

许多操作系统，软件框架和程序包括日志系统。广泛使用的日志记录标准是在因特网工程任务组（IETF）RFC5424中定义的syslog。 syslog标准使专用的标准化子系统能够生成，过滤，记录和分析日志消息。

**调试日志**

软件开发中，我们经常需要去调试程序，做一些信息，状态的输出便于我们查询程序的运行状况。为了让我们能够更加灵活和方便的控制这些调试的信息，所有我们需要专业的日志技术。java中寻找bug会需要重现。调试也就是debug 可以在程序运行中暂停程序运行，可以查看程序在运行中的情况。日志主要是为了更方便的去重现问题。

**系统日志**

系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。系统日志包括系统日志、应用程序日志和安全日志。

**系统日志的价值**

系统日志策略可以在故障刚刚发生时就向你发送警告信息，系统日志帮助你在最短的时间内发现问题。系统日志是一种非常关键的组件，因为系统日志可以让你充分了解自己的环境。这种系统日志信息对于决定故障的根本原因或者缩小系统攻击范围来说是非常关键的，因为系统日志可以让你了解故障或者袭击发生之前的所有事件。为虚拟化环境制定一套良好的系统日志策略也是至关重要的，因为系统日志需要和许多不同的外部组件进行关联。良好的系统日志可以防止你从错误的角度分析问题，避免浪费宝贵的排错时间。另外一种原因是借助于系统日志，管理员很有可能会发现一些之前从未意识到的问题，在几乎所有刚刚部署系统日志的环境当中。



## JAVA日志框架

### 为什么要用日志框架

因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处。



### 现有的日志框架

**日志门面**

JCL（Jakarta Commons Logging）、slf4j（Simple Logging Facade for Java）

**日志实现**

JUL（java util logging）、logback、log4j、log4j2



## JUL

JUL全称Java util Logging。是java原生的日志框架，使用时不需要另外引用第三方类库，相对其他日志框架使用方便，学习简单，能够在小型应用中灵活使用。

### JUL入门

#### 架构介绍

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/bb701123-dc2a-4802-b5a0-28a812e3e4a8" /></div>
- Loggers：被称为记录器，应用程序通过获取Logger对象，调用其API来来发布日志信息。Logger通常时应用程序访问日志系统的入口程序。


- Appenders：也被称为Handlers，每个Logger都会关联一组Handlers，Logger会将日志交给关联Handlers处理，由Handlers负责将日志做记录。Handlers在此是一个抽象，其具体的实现决定了日志记录的位置可以是控制台、文件、网络上的其他日志服务或操作系统日志等。
- Layouts：也被称为Formatters，它负责对日志事件中的数据进行转换和格式化。Layouts决定了数据在一条日志记录中的最终形式。
- Level：每条日志消息都有一个关联的日志级别。该级别粗略指导了日志消息的重要性和紧迫，我可以将Level和Loggers，Appenders做关联以便于我们过滤消息。
- Filters：过滤器，根据需要定制哪些信息会被记录，哪些信息会被放过。

总结一下就是：

用户使用Logger来进行日志记录，Logger持有若干个Handler，日志的输出操作是由Handler完成的。在Handler在输出日志前，会经过Filter的过滤，判断哪些日志级别过滤放行哪些拦截，Handler会将日志内容输出到指定位置（日志文件、控制台等）。Handler在输出日志时会使用Layout，将输出内容进行排版。

#### 入门案例

```java
public class JULTest {
    @Test
    public void testQuick() throws Exception {
        // 1.创建日志记录器对象
        Logger logger = Logger.getLogger("cn.isjinhao.log.JULTest");
        // 2.日志记录输出
        logger.info("hello jul");
        logger.log(Level.INFO, "info msg");
        String name = "jack";
        Integer age = 18;
        logger.log(Level.INFO, "用户信息：{0},{1}", new Object[]{name, age});
    }
}
```



### 日志的级别

**jul中定义的日志级别**

```java
java.util.logging.Level中定义了日志的级别：
        SEVERE（最高值）
        WARNING
        INFO （默认级别）
        CONFIG
        FINE
        FINER
        FINEST（最低值）
还有两个特殊的级别：
        OFF，可用来关闭日志记录。
        ALL，启用所有消息的日志记录。
```

**默认实现info以上级别** 

```java
@Test
public void testLogLevel() throws Exception {
    // 1.获取日志对象
    Logger logger = Logger.getLogger("cn.isjinhao.log.JULTest");
    // 2.日志记录输出
    logger.severe("severe");
    logger.warning("warning");
    logger.info("info");
    // 以下不会输出任何信息
    logger.config("config");
    logger.fine("fine");
    logger.finer("finer");
    logger.finest("finest");
}
```

**自定义日志级别配置**  

```java
@Test
public void testLogConfig() throws Exception {
    // 1.创建日志记录器对象
    Logger logger = Logger.getLogger("cn.isjinhao.log.JULTest");
    // 一、自定义日志级别
    // a.关闭系统默认配置
    logger.setUseParentHandlers(false);
    // b.创建handler对象
    ConsoleHandler consoleHandler = new ConsoleHandler();
    // c.创建formatter对象
    SimpleFormatter simpleFormatter = new SimpleFormatter();
    // d.进行关联
    consoleHandler.setFormatter(simpleFormatter);
    logger.addHandler(consoleHandler);
    // e.设置日志级别
    logger.setLevel(Level.ALL);
    consoleHandler.setLevel(Level.ALL);
    // 二、输出到日志文件
    FileHandler fileHandler = new FileHandler("d:/logs/jul.log");
    fileHandler.setFormatter(simpleFormatter);
    logger.addHandler(fileHandler);
    // 2.日志记录输出
    logger.severe("severe");
    logger.warning("warning");
    logger.info("info");
    logger.config("config");
    logger.fine("fine");
    logger.finer("finer");
    logger.finest("finest");
}
```



### Logger之间的父子关系

JUL中Logger之间存在父子关系，这种父子关系通过树状结构存储，JUL在初始化时会创建一个顶层RootLogger作为所有Logger父Logger，存储上作为树状结构的根节点。父子关系通过路径来关联。

```java
@Test
public void testLogParent() throws Exception {
    // 日志记录器对象父子关系
    Logger logger1 = Logger.getLogger("cn.isjinhao.log");	// 子 Logger
    Logger logger2 = Logger.getLogger("cn.isjinhao");		// 父 Logger
    System.out.println(logger1.getParent() == logger2);
    // 所有日志记录器对象的顶级父元素 class为java.util.logging.LogManager$RootLogger
    System.out.println("logger2 parent:" + logger2.getParent() + "，name：" +
                       logger2.getParent().getName());
    
    // 一、自定义日志级别
    // a.关闭系统默认配置
    logger2.setUseParentHandlers(false);
    // b.创建handler对象
    ConsoleHandler consoleHandler = new ConsoleHandler();
    // c.创建formatter对象
    SimpleFormatter simpleFormatter = new SimpleFormatter();
    // d.进行关联
    consoleHandler.setFormatter(simpleFormatter);
    logger2.addHandler(consoleHandler);
    // e.设置日志级别
    logger2.setLevel(Level.ALL);
    consoleHandler.setLevel(Level.ALL);
    // 测试日志记录器对象父子关系
    logger1.severe("severe");
    logger1.warning("warning");
    logger1.info("info");
    logger1.config("config");
    logger1.fine("fine");
    logger1.finer("finer");
    logger1.finest("finest");
}
```



### Filter

`Filter` 是用来对输出的日志信息进行过滤作用的，我们可以根据很多维度来对日志信息进行过滤，比如只输出message中包含某段文本信息的日志，或者只输出某个方法中记录的日志等等。具体能根据哪些维度来过滤我们后面介绍 `LogRecord` 的时候再回顾一下。本节只举两个例子，一个是根据具体文本信息进行过滤，另一个是根据方法名来过滤。

先简单地说一下 `java.util.logging.LogRecord` 类，该类对日志输出的过程中涉及到的各种属性进行封装，可以理解为通过 `LogRecord` 对象，我们可以获取该条日志的文本信息、日志生成的时间戳、日志来自于哪个类、日志来自于哪个方法、日志来自于哪个线程等等。日志记录器 `Logger` 对象的 `log()`方法中会将日志信息包装成一个LogRecord对象，最终会将该对象递交给 `Handler` 进行实际的输出操作，`LogRecord` 对象可以理解为是用来在JUL日志组件当中进行数据传递的DTO（数据传输对象）。

`Filter` 在JUL中是通过 `java.util.logging.Filter` 接口来表示的，该接口的声明如下：

```java
@FunctionalInterface
public interface Filter {

    /**
     * Check if a given log record should be published.
     * @param record  a LogRecord
     * @return true if the log record should be published.
     */
    public boolean isLoggable(LogRecord record);
}
```

该接口在java8中被声明为一个函数式接口，只有一个抽象方法：`boolean isLoggable(LogRecord record)`，如果该方法返回 true 就表示不过滤掉该日志，如果返回false就表示过滤掉该日志，从而不进行输出。在实际使用过程当中需要实现我们自己的过滤器。下面我们将实现两个过滤器，一个是为了构建和谐社会，对包含"Shit"信息的日志进行过滤的shitFilter，另一个是只对某个方法，如 `earnMoney()` 中记录的日志进行输出的earnMoneyFilter。

首先我们看一下没有Filter时的代码以及输出情况：

```java
public class JavaLogging {
    private static final Logger logger = Logger.getLogger(JavaLogging.class.getName());
    public static void main(String[] args) {
        logger.info("Freedom");
        logger.info("Equality");
        logger.info("Justice");
        logger.info("Rule of Law");
        logger.info("Shit! too young too simple, sometimes naive");
        earnMoney();
    }

    private static void earnMoney() {
        logger.info("earn lots of money.");
    }
}
```

输出如下：

```shell
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging main
信息: Freedom
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging main
信息: Equality
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging main
信息: Justice
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging main
信息: Rule of Law
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging main
信息: Shit! too young too simple, sometimes naive
四月 20, 2020 5:17:51 下午 cn.isjinhao.log.JavaLogging earnMoney
信息: earn lots of money.
```

所有的信息都输出来了，下面我们定义一个shitFilter来过滤掉"Shit! too young too simple, sometimes naive"这条日志。我们可以采用lambda表达式来进行定义，当然，通过显示地实现 `Filter` 接口的方式也是可以的，为了简单起见，我们直接用lambda表达式的语法。

```java
private static final Logger logger = Logger.getLogger(JavaLogging.class.getName());
static {
    Filter shitFilter = logRecord -> !logRecord.getMessage().contains("Shit");
    logger.setFilter(shitFilter);
}
```

输出为：

```shell
四月 20, 2020 5:18:25 下午 cn.isjinhao.log.JavaLogging main
信息: Freedom
四月 20, 2020 5:18:25 下午 cn.isjinhao.log.JavaLogging main
信息: Equality
四月 20, 2020 5:18:25 下午 cn.isjinhao.log.JavaLogging main
信息: Justice
四月 20, 2020 5:18:25 下午 cn.isjinhao.log.JavaLogging main
信息: Rule of Law
四月 20, 2020 5:18:25 下午 cn.isjinhao.log.JavaLogging earnMoney
信息: earn lots of money.
```

可以看到包含"Shit"信息的日志没有被输出来，达到了我们预期的过滤效果。同样地，我们再实现一个过滤器，用来只输出 `earnMoney()` 方法中记录的日志，其他方法（如main方法）中记录的日志我们不进行输出。`Filter` 实现如下：

```java
private static final Logger logger = Logger.getLogger(JavaLogging.class.getName());
static {
    Filter earnMoneyFilter = logRecord -> 
        "earnMoney".equals(logRecord.getSourceMethodName());
    logger.setFilter(earnMoneyFilter);
}
```

输出如下：

```shell
四月 20, 2020 5:18:41 下午 cn.isjinhao.log.JavaLogging earnMoney
信息: earn lots of money.
```

即只输出了我们指定的方法中记录的日志信息。相信大家可能也看出来了，能根据哪些维度进行过滤关键是看`LogRecord` 中对外提供了哪些信息。一旦我们对 `LogRecord` 中提供的信息有了更充分的了解，我们就能根据需要创建我们自己的 `Filter`，从而更好地控制我们日志的输出。



### LogRecord

`LogRecord` 类的 `get()` 方法如下所示：

```java
Level getLevel();
String getLoggerName();
String getMessage();
long getMillis();
Object[] getParameters();
ResourceBundle getResourceBundle();
String getResourceBundleName();
long getSequenceNumber();
String getSourceClassName();
String getSourceMethodName();
int getThreadID();
Throwable getThrown();
```

在记录日志的过程中可以直接使用 `LogRecord` 对象，也可以不直接使用 `LogRecord` 对象，而是由日志组件内部为我们自动组装成一个 `LogRecord` 对象。我们之前通过 `logger.info()` 这一类方法记录日志时，内部会根据我们传入的参数以及调用的方法自动组装成一个 `LogRecord` 对象。例如：

```java
logger.info("Hello");
```

该方法首先转调方法`logger.log(Level.INFO, “Hello”)`，该方法内部自动帮我们创建了 `LogRecord`：

```java
public void log(Level level, String msg) {
    if (!isLoggable(level)) {
        return;
    }
    LogRecord lr = new LogRecord(level, msg);
    doLog(lr);
}
```

`LogRecord` 给我们提供了一个含有两个参数的构造方法，第一个参数指定需要记录的信息的级别，第二个参数指定需要记录的信息，即：

```java
public LogRecord(Level level, String msg) {
    // Make sure level isn't null, by calling random method.
    level.getClass();
    this.level = level;
    message = msg;
    // Assign a thread ID and a unique sequence number.
    sequenceNumber = globalSequenceNumber.getAndIncrement();
    threadID = defaultThreadID();
    millis = System.currentTimeMillis();
    needToInferCaller = true;
}
```

当然我们也可以直接构造 `LogRecord` 对象，然后通过 `Logger.log(LogRecord record)` 方法来记录日志，如下所示：

```java
public class JavaLogging {
    private static final Logger logger = Logger.getLogger(JavaLogging.class.getName());
    public static void main(String[] args) {
        LogRecord infoLogRecord = new LogRecord(Level.INFO, "info");
        LogRecord severeLogRecord = new LogRecord(Level.SEVERE, "severe");
        logger.log(infoLogRecord);
        logger.log(severeLogRecord);
    }
}
```

但这样做显然不太方便，还是通过 `logger.info()`，`logger.warning` 这一类方法来记录日志更简便，当然这一类方法也有他们的局限处，比如无法传递 `Throwable` 类型的异常信息等。

`getLevel()` 方法返回的就是当前日志信息的级别，即通过 `logger.info()` 方法调用时，当前日志信息的级别为INFO级别，通过 `logger.severe() `方法调用时，当前日志信息级别为SEVERE级别。JUL中的级别涉及如下三个方面：

- 日志记录器（`Logger`）的级别
- 当前需要记录的日志信息（message）的级别
- 真正执行日志记录操作的 `Handler` 的级别

我们是要将当前需要记录的日志信息的级别与日志记录器 `Logger` 的级别以及 `Handler` 的级别相比较，只有高于或等于他们的信息才会被记录。首先是与 `Logger` 的级别进行比较，如果低于 `Logger` 的级别则直接不输出，如果高于或等于 `Logger` 的级别，到真正执行输出时还需要跟 `Handler` 的级别进行比较。

**getLoggerName()**

`getLoggerName()` 方法是获取当前日志记录器名字，日志记录器名字就是调用 `Logger.getLogger(String name)` 方法时传入的参数，在我们的例子中就是 cn.isjinhao.log.JavaLogging。

**getMillis()**

`getMillis()` 返回值默认就是创建 `LogRecord` 对象时的当前系统时间戳（从1970年到现在所经过的毫秒数），millis 属性值是在 `LogRecourd` 的构造方法中进行赋值的。

**getThrown()**

`getThrown()` 方法返回 `Throwable` 类型的信息，即获取异常信息，我们目前为止记录的日志信息只是记录一段message，并没有记录发生异常时的异常堆栈信息，要记录这种类型的信息，我们需要通过 `Logger.log()` 方法来进行日志的记录，`Logger.log` 有几种重载的方法，其中有一种就能传递 `Throwable` 信息，该方法如下所示：

```java
public void log(Level level, String msg, Throwable thrown) {
    if (!isLoggable(level)) {
        return;
    }
    LogRecord lr = new LogRecord(level, msg);
    lr.setThrown(thrown);
    doLog(lr);
}
```

可以看到将传入的 `Throwable` 类型参数赋值给了 `LogRecord` 对象的 thrown 属性，因此在 `LogRecord` 中通过`getThrown()` 方法就能获取到传入的 `Throwable` 信息，最终可以对异常堆栈信息进行输出。示例代码如下：

```java
private static final Logger logger = Logger.getLogger(JavaLogging.class.getName());
public static void main(String[] args) {
    logger.log(Level.SEVERE, "error", new NullPointerException("NPE"));
}
```

输出为：

```shell
四月 20, 2020 5:21:36 下午 cn.isjinhao.log.JavaLogging main
严重: error
java.lang.NullPointerException: NPE
	at cn.isjinhao.log.JavaLogging.main(JavaLogging.java:11)
```

**getSourceClassName()**

`getSourceClassName()` 方法用来获取记录日志的操作是在哪个类中进行的。

**getSourceMethodName()**

`getSourceMethodName()` 方法用来获取记录日志的操作是在哪个方法中进行的。

需要注意一点的是，上述两个方法所获取的类名和方法名有可能是不正确的。如果我们在记录日志的过程中没有主动设置这两个属性的值，那么这两个属性的值就会被自动推断出来，推断出来的结果有可能就会出现偏差。我们可以看一下 `getSourceClassName()` 方法内部实现：

```java
public String getSourceClassName() {
    if (needToInferCaller) {
        inferCaller();
    }
    return sourceClassName;
}
```

可以看到如果 `needToInferCaller` 的值为true时，就会执行 `inferCaller()` 方法对发起记录日志请求操作的类名和方法名进行推断，关于如何推断我们在这里不进行深入研究。

**getSequenceNumber()**

`getSequenceNumber()` 为每一个 `LogRecord` 对象都赋予一个唯一的序号，从0开始。每创建一个 `LogRecord` 对象该值就增加1，在 `LogRecord` 的构造方法中给该属性赋值：

```java
sequenceNumber = globalSequenceNumber.getAndIncrement();`
```

`globalSequenceNumber` 的声明如下：

```java
private static final AtomicLong globalSequenceNumber = new AtomicLong(0);
```

可以看出在系统运行期间，每一个 `LogRecord` 对象都有一个唯一的编号。

**getThreadId()**

`getThreadId()` 方法获取当前线程的id，需要注意的是该id有可能不是真正的线程id，构造方法中是通过如下语句对 `threadId` 进行赋值的：

```java
threadID = defaultThreadID();
```

**defaultThreadID()**

`defaultThreadID()` 方法如下：

```java
private int defaultThreadID() {
    long tid = Thread.currentThread().getId();
    if (tid < MIN_SEQUENTIAL_THREAD_ID) {
        return (int) tid;
    } else {
        Integer id = threadIds.get();
        if (id == null) {
            id = nextThreadId.getAndIncrement();
            threadIds.set(id);
        }
        return id;
    }
}
```

可以看到通过 `Thread.currentThread().getId()` 获取的线程id是long类型的，但是 `LogRecord` 中的threadId字段是int类型的，因此它们之间没办法做到一一对应。



### 配置文件管理日志

```java
@Test
public void testProperties() throws Exception {
    // 读取自定义配置文件
    InputStream in =
        JULTest.class.getClassLoader().getResourceAsStream("logging.properties");
    // 获取日志管理器对象
    LogManager logManager = LogManager.getLogManager();
    // 通过日志管理器加载配置文件
    logManager.readConfiguration(in);
    Logger logger = Logger.getLogger("cn.isjinhao.log.JULTest");
    logger.severe("severe");
    logger.warning("warning");
    logger.info("info");
    logger.config("config");
    logger.fine("fine");
    logger.finer("finer");
    logger.finest("finest");
}
```

配置文件 

```properties
# RootLogger使用的处理器（获取时设置）
handlers=java.util.logging.ConsoleHandler
# RootLogger日志等级
.level= INFO

## 自定义Logger
cn.isjinhao.handlers=java.util.logging.FileHandler
# 自定义Logger日志等级
cn.isjinhao.level= INFO
# 忽略父日志设置
cn.isjinhao.useParentHandlers=false

## 控制台处理器
# 输出日志级别
java.util.logging.ConsoleHandler.level=INFO
# 输出日志格式
java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter

## 文件处理器
# 输出日志级别
java.util.logging.FileHandler.level=INFO
# 输出日志格式
java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter
# 输出日志文件路径
java.util.logging.FileHandler.pattern=/java%u.log
# 输出日志文件限制大小（50000字节）
java.util.logging.FileHandler.limit=50000
# 输出日志文件限制个数
java.util.logging.FileHandler.count=10
# 输出日志文件 是否是追加
java.util.logging.FileHandler.append=true
```



### 日志原理解析  

1. 初始化LogManager
2. LogManager加载logging.properties配置
3. 添加Logger到LogManager
4. 从单例LogManager获取Logger
5. 设置级别Level，并指定日志记录LogRecord
6. Filter提供了日志级别之外更细粒度的控制
7. Handler是用来处理日志输出位置
8. Formatter是用来格式化LogRecord的  

<div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/07ce0a96-cbcf-456b-a341-c0df4481bc1f" /></div>
## LOG4j

Log4j 是 Apache 下的一款开源的日志框架，通过在项目中使用 Log4j，我们可以控制日志信息输出到控制台、文件、甚至是数据库中。我们可以控制每一条日志的输出格式，通过定义日志的输出级别，可以更灵活的控制日志的输出过程。方便项目的调试。官方网站： http://logging.apache.org/log4j/1.2/

### Log4j入门

maven依赖

```xml
<dependencies>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
</dependencies>
```

入门代码

```java
public void testQuick() throws Exception {
    // 初始化系统配置，不需要配置文件
    BasicConfigurator.configure();
    // 创建日志记录器对象
    Logger logger = Logger.getLogger(Log4jTest.class);
    // 日志记录输出
    logger.info("hello log4j");
    // 日志级别
    logger.fatal("fatal"); // 严重错误，一般会造成系统崩溃和终止运行
    logger.error("error"); // 错误信息，但不会影响系统运行
    logger.warn("warn"); // 警告信息，可能会发生问题
    logger.info("info"); // 程序运行信息，数据库的连接、网络、IO操作等
    logger.debug("debug"); // 调试信息，一般在开发阶段使用，记录程序的变量、参 数等
    logger.trace("trace"); // 追踪信息，记录程序的所有流程信息
}
```

日志的级别  

```
每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：
    fatal 指出每个严重的错误事件将会导致应用程序的退出。
    error 指出虽然发生错误事件，但仍然不影响系统的继续运行。
    warn 表明会出现潜在的错误情形。
    info 一般和在粗粒度级别上，强调应用程序的运行全程。
    debug 一般用于细粒度级别上，对调试应用程序非常有帮助。
    trace 是程序追踪，可以用于输出程序运行中的变量，显示执行的流程。
还有两个特殊的级别：
	OFF，可用来关闭日志记录。
	ALL，启用所有消息的日志记录
	
一般只使用4个级别，优先级从高到低为 ERROR > WARN > INFO > DEBUG
```



### Log4j组件

Log4j主要由Loggers (日志记录器)、Appenders（输出端）和 Layout（日志格式化器）组成。

- Loggers 控制日志的输出级别与日志是否输出；
- Appenders 指定日志的输出方式（输出到控制台、文件等）；
- Layout 控制日志信息的输出格式。

#### Loggers

日志记录器，负责收集处理日志记录，实例的命名就是类“XX”的full quailied name（类的全限定名），Logger的名字大小写敏感，其命名有继承机制：例如：name为org.apache.commons的logger会继承name为org.apache的logger。

Log4J中有一个特殊的logger叫做“root”，他是所有logger的根，也就意味着其他所有的logger都会直接或者间接地继承自root。root logger可以用Logger.getRootLogger()方法获取。

#### Appenders

Appender 用来指定日志输出到哪个地方，可以同时指定日志的输出目的地。Log4j 常用的输出目的地有以下几种：  

| 输出端类型               | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ConsoleAppender          | 将日志输出到控制台                                           |
| FileAppender             | 将日志输出到文件中                                           |
| DailyRollingFileAppender | 将日志输出到一个日志文件，并且每天输出到一个新的文件         |
| RollingFileAppender      | 将日志信息输出到一个日志文件，并且指定文件的尺寸，当文件大 小达到指定尺寸时，会自动把文件改名，同时产生一个新的文件 |
| JDBCAppender             | 把日志信息保存到数据库中                                     |

#### Layouts

布局器 Layouts用于控制日志输出内容的格式，让我们可以使用各种需要的格式输出日志。Log4j常用的Layouts:  

| 格式化器类型  | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| HTMLLayout    | 格式化日志输出为HTML表格形式                                 |
| SimpleLayout  | 简单的日志输出格式化，打印的日志格式为（info - message）     |
| PatternLayout | 最强大的格式化期，可以根据自定义格式输出日志，如果没有指定转换格式， 就是用默认的转换格式 |



### Layout的格式

```
log4j 采用类似 C 语言的 printf 函数的打印格式格式化日志信息，具体的占位符及其含义如下：
	%m 输出代码中指定的日志信息
	%p 输出优先级，及 DEBUG、INFO 等
	%n 换行符（Windows平台的换行符为 "\n"，Unix 平台为 "\n"）
	%r 输出自应用启动到输出该 log 信息耗费的毫秒数
	%c 输出打印语句所属的类的全名
	%t 输出产生该日志的线程全名
	%d 输出服务器当前时间，默认为 ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日HH:mm:ss}
	%l 输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10)
	%F 输出日志消息产生时所在的文件名称
	%L 输出代码中的行号
	%% 输出一个 "%" 字符
可以在 % 与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式。如：
	%5c 输出category名称，最小宽度是5，category<5，默认的情况下右对齐
	%-5c 输出category名称，最小宽度是5，category<5，"-"号指定左对齐,会有空格
	%.5c 输出category名称，最大宽度是5，category>5，就会将左边多出的字符截掉，<5不会有空格
	%20.30c category名称<20补空格，并且右对齐，>30字符，就将左边较远处的字符截掉
```



### Appender的输出

控制台，文件，数据库

```properties
# 指定 RootLogger 顶级父元素默认配置信息
# 指定日志级别=trace，使用的 apeender 为=console
log4j.rootLogger=trace,console

# 自定义 logger 对象设置
log4j.logger.com.itheima=info,console
log4j.logger.org.apache=error

# 指定控制台日志输出的 appender
log4j.appender.console=org.apache.log4j.ConsoleAppender
# 指定消息格式 layout
log4j.appender.console.layout=org.apache.log4j.PatternLayout
# 指定消息格式的内容
log4j.appender.console.layout.conversionPattern=[%-10p]%r %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n


# %m   输出代码中指定的日志信息
# %p   输出优先级，及 DEBUG、INFO 等
# %n   换行符（Windows平台的换行符为 "\n"，Unix 平台为 "\n"）
# %r   输出自应用启动到输出该 log 信息耗费的毫秒数
# %c   输出打印语句所属的类的全名
# %t   输出产生该日志的线程全名
# %d   输出服务器当前时间，默认为 ISO8601，也可以指定格式，如：%d{yyyy年MM月dd日 HH:mm:ss}
# %l   输出日志时间发生的位置，包括类名、线程、及在代码中的行数。如：Test.main(Test.java:10)
# %F   输出日志消息产生时所在的文件名称
# %L   输出代码中的行号
# %%   输出一个 "%" 字符

# 日志文件输出的 appender 对象
log4j.appender.file = org.apache.log4j.FileAppender
# 指定消息格式 layout
log4j.appender.file.layout = org.apache.log4j.PatternLayout
# 指定消息格式的内容
log4j.appender.file.layout.conversionPattern = [%-10p]%r  %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n
# 指定日志文件保存路径
log4j.appender.file.file = /logs/log4j.log
# 指定日志文件的字符集
log4j.appender.file.encoding = UTF-8


# 按照文件大小拆分的 appender 对象
# 日志文件输出的 appender 对象
log4j.appender.rollingFile = org.apache.log4j.RollingFileAppender
# 指定消息格式 layout
log4j.appender.rollingFile.layout = org.apache.log4j.PatternLayout
# 指定消息格式的内容
log4j.appender.rollingFile.layout.conversionPattern = [%-10p]%r  %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n
# 指定日志文件保存路径
log4j.appender.rollingFile.file = /logs/log4j.log
# 指定日志文件的字符集
log4j.appender.rollingFile.encoding = UTF-8
# 指定日志文件内容的大小
log4j.appender.rollingFile.maxFileSize = 1MB 
# 指定日志文件的数量
log4j.appender.rollingFile.maxBackupIndex = 10


# 按照时间规则拆分的 appender 对象
log4j.appender.dailyFile = org.apache.log4j.DailyRollingFileAppender
# 指定消息格式 layout
log4j.appender.dailyFile.layout = org.apache.log4j.PatternLayout
# 指定消息格式的内容
log4j.appender.dailyFile.layout.conversionPattern = [%-10p]%r  %l %d{yyyy-MM-dd HH:mm:ss.SSS} %m%n
# 指定日志文件保存路径
log4j.appender.dailyFile.file = /logs/log4j.log
# 指定日志文件的字符集
log4j.appender.dailyFile.encoding = UTF-8
# 指定日期拆分规则
log4j.appender.dailyFile.datePattern = '.'yyyy-MM-dd-HH-mm-ss


#mysql
log4j.appender.logDB=org.apache.log4j.jdbc.JDBCAppender
log4j.appender.logDB.layout=org.apache.log4j.PatternLayout
log4j.appender.logDB.Driver=com.mysql.jdbc.Driver
log4j.appender.logDB.URL=jdbc:mysql://localhost:3306/test
log4j.appender.logDB.User=root
log4j.appender.logDB.Password=root
log4j.appender.logDB.Sql=INSERT INTO log(project_name,create_date,level,category,file_name,thread_name,line,all_category,message) values('itcast','%d{yyyy-MM-dd HH:mm:ss}','%p','%c','%F','%t','%L','%l','%m')
```

数据库

```sql
CREATE TABLE `log` (
`log_id` int(11) NOT NULL AUTO_INCREMENT,
`project_name` varchar(255) DEFAULT NULL COMMENT '目项名',
`create_date` varchar(255) DEFAULT NULL COMMENT '创建时间',
`level` varchar(255) DEFAULT NULL COMMENT '优先级',
`category` varchar(255) DEFAULT NULL COMMENT '所在类的全名',
`file_name` varchar(255) DEFAULT NULL COMMENT '输出日志消息产生时所在的文件名称 ',
`thread_name` varchar(255) DEFAULT NULL COMMENT '日志事件的线程名',
`line` varchar(255) DEFAULT NULL COMMENT '号行',
`all_category` varchar(255) DEFAULT NULL COMMENT '日志事件的发生位置',
`message` varchar(4000) DEFAULT NULL COMMENT '输出代码中指定的消息',
PRIMARY KEY (`log_id`)
);
```



## JCL 学习

全称为Jakarta Commons Logging，是 `Apache` 提供的一个通用日志API。它是为 "所有的Java日志实现"提供一个统一的接口，它自身也提供一个日志的实现，但是功能非常常弱（`SimpleLog`）。所以一般不会单独使用它。他允许开发人员使用不同的具体日志实现工具：`Log4j`,、jdk自带的日志（JUL)。JCL 有两个基本的抽象类：`Log`（基本记录器）和 `LogFactory` 。（负责创建 `Log` 实例）。

<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/619f837b-94e1-4071-837e-b12ca81471c6" /></div>
Maven依赖

```xml
<dependencies>
    <dependency>
        <groupId>commons-logging</groupId>
        <artifactId>commons-logging</artifactId>
        <version>1.2</version>
    </dependency>

    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>

    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
    </dependency>
</dependencies>
```

代码

```java
public void testQuick() throws Exception{
    // 获取 log日志记录器对象
    Log log = LogFactory.getLog(JCLTest.class);
    System.out.println(log.getClass());
    // 日志记录输出
    log.info("hello jcl");
}
```

加载顺序

```java
// 按照数组 index 顺序加载
private static final String[] classesToDiscover =
    new String[]{"org.apache.commons.logging.impl.Log4JLogger",
                 "org.apache.commons.logging.impl.Jdk14Logger",
                 "org.apache.commons.logging.impl.Jdk13LumberjackLogger",
                 "org.apache.commons.logging.impl.SimpleLog"};
```

比如如果上面的依赖没有依赖 Log4j 的包，输出 `Jdk14Logger`，依赖了则输出 `Log4JLogger`。



## slf4j

简单日志门面 slf4j（Simple Logging Facade For Java）主要是为了给 Java 日志访问提供一套标准、规范的API框架，其主要意义在于提供接口，具体的实现可以交由其他日志框架，例如 log4j 和 logback 等。当然 slf4j 自己也提供了功能较为简单的实现，但是一般很少用到。对于一般的 Java 项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。  

slf4j 是目前市面上最流行的日志门面。现在的项目中，基本上都是使用 slf4j 作为我们的日志系统。  slf4j 日志门面主要提供两大功能：

1. 日志框架的绑定
2. 日志框架的桥接  

添加依赖  

```xml
<!--slf4j core 使用slf4j必須添加-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.27</version>
</dependency>
<!--slf4j 自带的简单日志实现 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-simple</artifactId>
    <version>1.7.27</version>
</dependency>
```

编写代码  

```java
public class Slf4jTest {
    // 声明日志对象
    public final static Logger LOGGER = LoggerFactory.getLogger(Slf4jTest.class);
    
    @Test
    public void testQuick() throws Exception {
        //打印日志信息
        LOGGER.error("error");
        LOGGER.warn("warn");
        LOGGER.info("info");
        LOGGER.debug("debug");
        LOGGER.trace("trace");
        // 使用占位符输出日志信息
        String name = "jack";
        Integer age = 18;
        LOGGER.info("用户：{},{}", name, age);
        // 将系统异常信息写入日志
        try {
            int i = 1 / 0;
        } catch (Exception e) {
            // e.printStackTrace();
            LOGGER.info("出现异常：", e);
        }
    }
}
```

**为什么要使用SLF4J作为日志门面**  

1. 使用SLF4J框架，可以在部署时迁移到所需的日志记录框架。
2. SLF4J提供了对所有流行的日志框架的绑定，例如log4j，JUL，Simple logging和NOP。因此可以在部署时切换到任何这些流行的框架。
3. 无论使用哪种绑定，SLF4J都支持参数化日志记录消息。由于SLF4J将应用程序和日志记录框架分离，因此可以轻松编写独立于日志记录框架的应用程序。而无需担心用于编写应用程序的日志记录框架。
4. SLF4J提供了一个简单的Java工具，称为迁移器。使用此工具，可以迁移现有项目，这些项目使用日志框架(如Jakarta Commons Logging(JCL)或log4j或Java.util.logging(JUL))到SLF4J。



### 绑定日志的实现（Binding）  

如前所述，SLF4J支持各种日志框架。SLF4J发行版附带了几个称为“SLF4J绑定”的jar文件，每个绑定对应一个受支持的框架。

**使用slf4j的日志绑定流程**：

1. 添加slf4j-api的依赖
2. 使用slf4j的API在项目中进行统一的日志记录
3. 绑定具体的日志实现框架
   1. 绑定已经实现了slf4j的日志框架,直接添加对应依赖
   2. 绑定没有实现slf4j的日志框架,先添加日志的适配器,再添加实现类的依赖
4. slf4j有且仅有一个日志实现框架的绑定（如果出现多个默认使用第一个依赖日志实现）  

常见的日志实现框架：

```xml
<!--slf4j core 使用slf4j必須添加-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.27</version>
</dependency>

<!-- log4j-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-log4j12</artifactId>
    <version>1.7.27</version>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>

<!-- jul -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-jdk14</artifactId>
    <version>1.7.27</version>
</dependency>
```

<div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/1e56b496-7a81-4872-ac7a-431798451aaf" /></div>

### 桥接旧的日志框架（Bridging）  

通常，您依赖的某些组件依赖于SLF4J以外的日志记录API。您也可以假设这些组件在不久的将来不会切换到LF4J。为了解决这种情况，SLF4J附带了几个桥接模块，这些模块将对log4j，JCL和java.util.logging API的调用重定向，就好像它们是对SLF4J API一样。  

桥接解决的是项目中日志的遗留问题，当系统中存在之前的日志API，可以通过桥接转换到slf4j的实现

1. 先去除之前老的日志框架的依赖
2. 加SLF4J提供的桥接组件
3. 为项目添加SLF4J的具体实现  

<div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/423d5a35-4a70-4b87-95a8-361aed308a84" /></div>
迁移的方式：

如果我们要使用SLF4J的桥接器，替换原有的日志框架，那么我们需要做的第一件事情，就是删除掉原有项目中的日志框架的依赖。然后替换成SLF4J提供的桥接器。  

```xml
<!-- log4j-->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>log4j-over-slf4j</artifactId>
    <version>1.7.27</version>
</dependency>
<!-- jul -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jul-to-slf4j</artifactId>
    <version>1.7.27</version>
</dependency>
<!--jcl -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jcl-over-slf4j</artifactId>
    <version>1.7.27</version>
</dependency>
```

注意问题：

1. jcl-over-slf4j.jar和 slf4j-jcl.jar不能同时部署。前一个jar文件将导致JCL将日志系统的选择委托给SLF4J，后一个jar文件将导致SLF4J将日志系统的选择委托给JCL，从而导致无限循环。
2. log4j-over-slf4j.jar和slf4j-log4j12.jar不能同时出现
3. jul-to-slf4j.jar和slf4j-jdk14.jar不能同时出现
4. 所有的桥接都只对Logger日志记录器对象有效，如果程序中调用了内部的配置类或者是Appender,Filter等对象，将无法产生效果。 



## Logback

Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好。官方网站：https://logback.qos.ch/index.html。Logback主要分为三个模块：

1. logback-core：其它两个模块的基础模块
2. logback-classic：它是log4j的一个改良版本，同时它完整实现了slf4j API
3. logback-access：访问模块与Servlet容器集成提供通过Http来访问日志的功能

后续的日志代码都是通过SLF4J日志门面搭建日志系统，所以在代码是没有区别，主要是通过修改配置文件和pom.xml依赖 。



### logback入门

添加依赖  

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

java代码  

```java
// 定义日志对象
public final static Logger LOGGER = LoggerFactory.getLogger(LogBackTest.class);
@Test
public void testSlf4j(){
    // 打印日志信息
    LOGGER.error("error");
    LOGGER.warn("warn");
    LOGGER.info("info");
    LOGGER.debug("debug");
    LOGGER.trace("trace");
}
```



### logback配置

logback会依次读取以下类型配置文件：

1. logback.groovy
2. logback-test.xml
3. logback.xml 如果均不存在会采用默认配置

logback组件之间的关系
1. Logger：日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。
2. Appender：用于指定日志输出的目的地，目的地可以是控制台、文件、数据库等等。
3. Layout：负责把事件转换成字符串，格式化的日志信息的输出。在logback中Layout对象被封装在encoder中。

基本配置信息  

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--
        配置集中管理属性
        我们可以直接改属性的 value 值
        格式：${name}
    -->
    <property name="pattern" value="[%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} %c %M %L [%thread] %m%n"></property>
    <!--
    日志输出格式：
        %-5level
        %d{yyyy-MM-dd HH:mm:ss.SSS}日期
        %c类的完整名称
        %M为method
        %L为行号
        %thread线程名称
        %m或者%msg为信息
        %n换行
      -->
    <!--定义日志文件保存路径属性-->
    <property name="log_dir" value="/logs"></property>

    <!--控制台日志输出的 appender-->
    <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
        <!--控制输出流对象 默认 System.out 改为 System.err-->
        <target>System.err</target>
        <!--日志消息格式配置-->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>

    <!--日志文件输出的 appender-->
    <appender name="file" class="ch.qos.logback.core.FileAppender">
        <!--日志文件保存路径-->
        <file>${log_dir}/logback.log</file>
        <!--日志消息格式配置-->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
    </appender>

    <!--html 格式日志文件输出 appender-->
    <appender name="htmlFile" class="ch.qos.logback.core.FileAppender">
        <!--日志文件保存路径-->
        <file>${log_dir}/logback.html</file>
        <!--html 消息格式配置-->
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="ch.qos.logback.classic.html.HTMLLayout">
                <pattern>%-5level%d{yyyy-MM-dd HH:mm:ss.SSS}%c%M%L%thread%m</pattern>
            </layout>
        </encoder>
    </appender>

    <!--日志拆分和归档压缩的 appender 对象-->
    <appender name="rollFile" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--日志文件保存路径-->
        <file>${log_dir}/roll_logback.log</file>
        <!--日志消息格式配置-->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>${pattern}</pattern>
        </encoder>
        <!--指定拆分规则-->
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!--按照时间和压缩格式声明拆分的文件名-->
            <fileNamePattern>${log_dir}/rolling.%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>
            <!--按照文件大小拆分-->
            <maxFileSize>1MB</maxFileSize>
        </rollingPolicy>
        <!--日志级别过滤器-->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!--日志过滤规则-->
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!--异步日志-->
    <appender name="async" class="ch.qos.logback.classic.AsyncAppender">
        <!--指定某个具体的 appender-->
        <appender-ref ref="rollFile"/>
    </appender>


    <!--root logger 配置-->
    <root level="ALL">
        <appender-ref ref="console"/>
        <appender-ref ref="async"/>
    </root>

    <!--自定义 looger 对象
        additivity="false" 自定义 logger 对象是否继承 rootLogger
     -->
    <logger name="com.itheima" level="info" additivity="false">
        <appender-ref ref="console"/>
    </logger>
</configuration>
```



## log4j2的使用

Apache Log4j 2是对Log4j的升级版，参考了logback的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要有：

- 异常处理，在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。
- 性能提升， log4j2相较于log4j 和logback都具有很明显的性能提升，后面会有官方测试的数据。
- 自动重载配置，参考了logback的设计，当然会提供自动刷新参数配置，最实用的就是我们在生产上可以动态的修改日志的级别而不需要重启应用。
- 无垃圾机制，log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集
  导致的jvm gc。

官网： https://logging.apache.org/log4j/2.x/  



### Log4j2入门  

目前市面上最主流的日志门面就是SLF4J，虽然Log4j2也是日志门面，因为它的日志实现功能非常强大，性能优越。所以大家一般还是将Log4j2看作是日志的实现，Slf4j + Log4j2应该是未来的大势所趋。  

添加依赖

```xml
<!-- Log4j2 门面API-->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.11.1</version>
</dependency>
<!-- Log4j2 日志实现 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.11.1</version>
</dependency>
```

JAVA代码 

```java
public class Log4j2Test {
    // 定义日志记录器对象
    public static final Logger LOGGER = LogManager.getLogger(Log4j2Test.class);
    
    @Test
    public void testQuick() throws Exception {
        LOGGER.fatal("fatal");
        LOGGER.error("error");
        LOGGER.warn("warn");
        LOGGER.info("info");
        LOGGER.debug("debug");
        LOGGER.trace("trace");
    }
}
```

使用slf4j作为日志的门面,使用log4j2作为日志的实现  

```xml
<!-- Log4j2 门面API-->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>2.11.1</version>
</dependency>

<!-- Log4j2 日志实现 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.11.1</version>
</dependency>

<!--使用slf4j作为日志的门面,使用log4j2来记录日志 -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>

<!--为slf4j绑定日志实现 log4j2的适配器 -->
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>2.10.0</version>
</dependency>
```

配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!--
    status="warn" 日志框架本身的输出日志级别
    monitorInterval="5" 自动加载配置文件的间隔时间，不低于 5 秒
-->
<Configuration status="debug" monitorInterval="5">
    <!--
        集中配置属性进行管理
        使用时通过:${name}
    -->
    <properties>
        <property name="LOG_HOME">/logs</property>
    </properties>

    <!--日志处理-->
    <Appenders>
        <!--控制台输出 appender-->
        <Console name="Console" target="SYSTEM_ERR">
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] [%-5level] %c{36}:%L --- %m%n" />
        </Console>

        <!--日志文件输出 appender-->
        <File name="file" fileName="${LOG_HOME}/myfile.log">
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %c{36} - %m%n" />
        </File>

        <!--使用随机读写刘的日志文件输出 appender，性能提高-->
        <RandomAccessFile name="accessFile" fileName="${LOG_HOME}/myAcclog.log">
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %c{36} - %m%n" />
        </RandomAccessFile>

        <!--按照一定规则拆分的日志文件的 appender-->
        <RollingFile name="rollingFile" fileName="${LOG_HOME}/myrollog.log"
                     filePattern="/logs/$${date:yyyy-MM-dd}/myrollog-%d{yyyy-MM-dd-HH-mm}-%i.log">
            <!--日志级别过滤器-->
            <ThresholdFilter level="debug" onMatch="ACCEPT" onMismatch="DENY" />
            <!--日志消息格式-->
            <PatternLayout pattern="[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %c{36} - %msg%n" />
            <Policies>
                <!--在系统启动时，出发拆分规则，生产一个新的日志文件-->
                <OnStartupTriggeringPolicy />
                <!--按照文件大小拆分，10MB -->
                <SizeBasedTriggeringPolicy size="10 MB" />
                <!--按照时间节点拆分，规则根据filePattern定义的-->
                <TimeBasedTriggeringPolicy />
            </Policies>
            <!--在同一个目录下，文件的个数限定为 30 个，超过进行覆盖-->
            <DefaultRolloverStrategy max="30" />
        </RollingFile>

    </Appenders>

    <!--logger 定义-->
    <Loggers>
        <!--自定义异步 logger 对象
            includeLocation="false" 关闭日志记录的行号信息
            additivity="false" 不在继承 rootlogger 对象
        -->
        <AsyncLogger name="cn.isjinhao" level="trace" includeLocation="false" additivity="false">
            <AppenderRef ref="Console"/>
        </AsyncLogger>

        <!--使用 rootLogger 配置 日志级别 level="trace"-->
        <Root level="trace">
            <!--指定日志使用的处理器-->
            <AppenderRef ref="Console" />

            <!--使用异步 appender-->
            <AppenderRef ref="Async" />
        </Root>
    </Loggers>
</Configuration>
```

配置异步日志需要添加依赖

```xml
<!--异步日志依赖-->
<dependency>
    <groupId>com.lmax</groupId>
    <artifactId>disruptor</artifactId>
    <version>3.3.4</version>
</dependency>  
```

AsyncLogger才是log4j2 的重头戏，也是官方推荐的异步方式。它可以使得调用Logger.log返回的更快。你可以有两种选择：全局异步和混合异步。

**全局异步**就是，所有的日志都异步的记录，在配置文件上不用做任何改动，只需要添加一个log4j2.component.properties文件，并在里面配置：  

```properties
Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector
```

混合异步就是，你可以在应用中同时使用同步日志和异步日志，这使得日志的配置方式更加灵活。  

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
    <properties>
        <property name="LOG_HOME">D:/logs</property>
    </properties>
    <Appenders>
        <File name="file" fileName="${LOG_HOME}/myfile.log">
            <PatternLayout>
                <Pattern>%d %p %c{1.} [%t] %m%n</Pattern>
            </PatternLayout>
        </File>
        <Async name="Async">
            <AppenderRef ref="file"/>
        </Async>
    </Appenders>
    <Loggers>
        <AsyncLogger name="com.itheima" level="trace"
                     includeLocation="false" additivity="false">
            <AppenderRef ref="file"/>
        </AsyncLogger>
        <Root level="info" includeLocation="true">
            <AppenderRef ref="file"/>
        </Root>
    </Loggers>
</Configuration>
```



## SpringBoot中的日志使用  

springboot框架在企业中的使用越来越普遍，springboot日志也是开发中常用的日志系统。springboot默认就是使用SLF4J作为日志门面，logback作为日志实现来记录日志。

**SpringBoot中的日志设计**

springboot中的日志

```xml
<dependency>
    <artifactId>spring-boot-starter-logging</artifactId>
    <groupId>org.springframework.boot</groupId>
</dependency>
```

依赖关系图：  

<div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/4d941c3f-5ce3-4474-8a51-fbd95f7a7d0f" /></div>
总结：

1. springboot 底层默认使用logback作为日志实现。
2. 使用了SLF4J作为日志门面
3. 将JUL也转换成slf4j
4. 也可以使用log4j2作为日志门面，但是最终也是通过slf4j调用logback  

**SpringBoot日志使用**  

在springboot中测试打印日志 

```java
@SpringBootTest
class SpringbootLogApplicationTests {
    //记录器
    public static final Logger LOGGER =
        LoggerFactory.getLogger(SpringbootLogApplicationTests.class);
    @Test
    public void contextLoads() {
        // 打印日志信息
        LOGGER.error("error");
        LOGGER.warn("warn");
        LOGGER.info("info"); // 默认日志级别
        LOGGER.debug("debug");
        LOGGER.trace("trace");
    }
}
```

修改默认日志配置

```properties
logging.level.com.itheima=trace
# 在控制台输出的日志的格式 同logback
logging.pattern.console=%d{yyyy-MM-dd} [%thread] [%-5level] %logger{50} -%msg%n
# 指定文件中日志输出的格式
logging.file=D:/logs/springboot.log
logging.pattern.file=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
```

指定配置 

给类路径下放上每个日志框架自己的配置文件；SpringBoot就不使用默认配置的了  

| 日志框架 | 配置文件                         |
| -------- | -------------------------------- |
| Logback  | logback-spring.xml , logback.xml |
| Log4j2   | log4j2-spring.xml ， log4j2.xml  |
| JUL      | logging.properties               |

使用SpringBoot解析日志配置

logback-spring.xml：由SpringBoot解析日志配置  

```xml
<encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
    <--进行开发和生产环境配置切换-->
    <springProfile name="dev">
        <pattern>${pattern}</pattern>
    </springProfile>
    <springProfile name="pro">
        <pattern>%d{yyyyMMdd:HH:mm:ss.SSS} [%thread] %-5level%msg%n</pattern>
    </springProfile>
</encoder>
```

application.properties  

```properties
spring.profiles.active=dev
```

将日志切换为log4j2  

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!--排除logback-->
        <exclusion>
            <artifactId>spring-boot-starter-logging</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
<!-- 添加log4j2 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

